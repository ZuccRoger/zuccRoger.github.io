<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>面试官:java线程池是如何实现的,定时线程怎么做到的定时运行？</title>
    <link href="/2022/05/09/%E9%9D%A2%E8%AF%95%E5%AE%98-java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84-%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%EF%BC%9F/"/>
    <url>/2022/05/09/%E9%9D%A2%E8%AF%95%E5%AE%98-java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84-%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试官:请介绍一些类加载,双亲委派模型</title>
    <link href="/2022/05/09/%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/05/09/%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类加载的过程分为加载、链接和初始化。</p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>Java将字节码从不同的数据源读取到JVM中，并映射为JVM认可的数据结构(Class对象),这里的数据源可以是各种各样形态的，比如jar文件、class文件,甚至是网络数据源，如果输入数据不是ClassFile的结构，则会抛出ClassFormatError.</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>简单来说就是将定义的类信息平滑地转入到JVM的运行过程中.</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>这个是虚拟机安全的保障,JVM需要核验一下字节信息是否符合JVM的规范,否则就会被认定为<strong>VerifyError</strong>，这样就防止了恶意信息危害JVM的运行，验证阶段可能会触发更多的class加载。</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>创建类或者接口中的静态变量，并且初始化静态变量（侧重在内存空间的分配上）</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>会将常量池中的符号引用替换为直接引用</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>真正地去执行类的初始化代码逻辑，包括静态字段的赋值，以及执行类定义中的静态初始化块内的逻辑。</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>就是说类加载器试图加载某个类型的时候，除非父类型找不到相应的类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模式的目的是为了避免重复加载Java类型。</p><h3 id="类加载机制的3个基本特征"><a href="#类加载机制的3个基本特征" class="headerlink" title="类加载机制的3个基本特征"></a>类加载机制的3个基本特征</h3><ol><li>双亲委派模型</li><li>可见行</li><li>单一性</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://time.geekbang.org/column/article/9946">请介绍类加载过程，什么是双亲委派模型？</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指OfferII076数组中的第k大的数字</title>
    <link href="/2022/05/09/%E5%89%91%E6%8C%87OfferII076%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/05/09/%E5%89%91%E6%8C%87OfferII076%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h5 id="全量快排"><a href="#全量快排" class="headerlink" title="全量快排"></a>全量快排</h5><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/9 7:37 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;运行结果</span><br><span class="hljs-comment"> *     &lt;p&gt;执行用时： 31 ms , 在所有 Java 提交中击败了 8.13% 的用户</span><br><span class="hljs-comment"> *     &lt;p&gt;内存消耗： 41.6 MB , 在所有 Java 提交中击败了 32.63% 的用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">kthLargest</span> <span class="hljs-operator">=</span> findKthLargest(ints, <span class="hljs-number">2</span>);<br>    System.out.println(kthLargest);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums[k - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> getPartition(nums, start, end);<br>      quickSort(nums, partition + <span class="hljs-number">1</span>, end);<br>      quickSort(nums, start, partition - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">splitNumber</span> <span class="hljs-operator">=</span> nums[start];<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &gt;= nums[end]) &#123;<br>        end--;<br>      &#125;<br>      swap(nums, start, end);<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &lt;= nums[start]) &#123;<br>        start++;<br>      &#125;<br>      swap(nums, start, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpVal</span> <span class="hljs-operator">=</span> nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = tmpVal;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="局部快排"><a href="#局部快排" class="headerlink" title="局部快排"></a>局部快排</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/9 9:21 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">kthLargest</span> <span class="hljs-operator">=</span> findKthLargest(ints, <span class="hljs-number">2</span>);<br>    System.out.println(kthLargest);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最后一个参数表示我们要找的是下标为k-1的数</span><br>    <span class="hljs-type">int</span>[] ints = quickSearch(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> ints[k - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] quickSearch(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> getPartition(nums, lo, hi);<br>    <span class="hljs-keyword">if</span> (j == k) &#123;<br>      <span class="hljs-keyword">return</span> Arrays.copyOf(nums, j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span><br>    <span class="hljs-keyword">return</span> j &gt; k ? quickSearch(nums, lo, j - <span class="hljs-number">1</span>, k) : quickSearch(nums, j + <span class="hljs-number">1</span>, hi, k);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">splitNumber</span> <span class="hljs-operator">=</span> nums[start];<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &gt;= nums[end]) &#123;<br>        end--;<br>      &#125;<br>      swap(nums, start, end);<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &lt;= nums[start]) &#123;<br>        start++;<br>      &#125;<br>      swap(nums, start, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpVal</span> <span class="hljs-operator">=</span> nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = tmpVal;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2022/05/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>java中提供的Arrays.sort方法对于基础类型的排序的底层实现就是采用的快速排序方法.</p> <figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/9 7:48 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> array[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">14</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;;<br>    System.out.println(<span class="hljs-string">&quot;排序前序列为：&quot;</span>);<br>    printArray(array);<br>    quickSort(array, <span class="hljs-number">0</span>, array.length - <span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;排序后序列为：&quot;</span>);<br>    printArray(array);<br>  &#125;<br><br>  <span class="hljs-comment">// 快速排序算法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> partition(array, start, end);<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 注意： 这要+1 和 -1</span><br><span class="hljs-comment">       *</span><br><span class="hljs-comment">       * &lt;p&gt;因为我们的初始化splitNumber 的值是 array[start] 所以这个start特别关键.</span><br><span class="hljs-comment">       *</span><br><span class="hljs-comment">       * &lt;p&gt;如果我们每次start一样的话，就无法就行 区分 左右。 对 partition;</span><br><span class="hljs-comment">       */</span><br>      quickSort(array, partition + <span class="hljs-number">1</span>, end);<br>      quickSort(array, start, partition - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/** 分区操作 */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">splitNumber</span> <span class="hljs-operator">=</span> array[start];<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>      <span class="hljs-comment">/** 注意这里是&lt;= 否则会造成死循环 */</span><br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &lt;= array[end]) &#123;<br>        end--;<br>      &#125;<br>      swap(array, start, end);<br>      <span class="hljs-comment">/** 注意这里是&gt;= */</span><br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &gt;= array[start]) &#123;<br>        start++;<br>      &#125;<br>      swap(array, start, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>  &#125;<br><br>  <span class="hljs-comment">// 交换序列中元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];<br>    array[i] = array[j];<br>    array[j] = temp;<br>  &#125;<br><br>  <span class="hljs-comment">// 打印序列中元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> array.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i != length - <span class="hljs-number">1</span>) &#123;<br>        System.out.print(array[i] + <span class="hljs-string">&quot; &quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(array[i]);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>topK</title>
    <link href="/2022/05/08/topK/"/>
    <url>/2022/05/08/topK/</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="全量排序"><a href="#全量排序" class="headerlink" title="全量排序"></a>全量排序</h5><p>但是结果发现效率不高</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/9 7:37 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;运行结果</span><br><span class="hljs-comment"> *     &lt;p&gt;执行用时： 31 ms , 在所有 Java 提交中击败了 8.13% 的用户</span><br><span class="hljs-comment"> *     &lt;p&gt;内存消耗： 41.6 MB , 在所有 Java 提交中击败了 32.63% 的用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">kthLargest</span> <span class="hljs-operator">=</span> findKthLargest(ints, <span class="hljs-number">2</span>);<br>    System.out.println(kthLargest);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums[k - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> getPartition(nums, start, end);<br>      quickSort(nums, partition + <span class="hljs-number">1</span>, end);<br>      quickSort(nums, start, partition - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">splitNumber</span> <span class="hljs-operator">=</span> nums[start];<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &gt;= nums[end]) &#123;<br>        end--;<br>      &#125;<br>      swap(nums, start, end);<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &lt;= nums[start]) &#123;<br>        start++;<br>      &#125;<br>      swap(nums, start, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpVal</span> <span class="hljs-operator">=</span> nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = tmpVal;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意</strong>找前 K 大&#x2F;前 K 小问题不需要对整个数组进行 O(NlogN)<em>O</em>(<em>N<strong>l</strong>o<strong>g</strong>N</em>) 的排序！</p><h5 id="局部快排"><a href="#局部快排" class="headerlink" title="局部快排"></a>局部快排</h5><p>思想：快排的每一次partition返回的是一个下标，这个下标左边所有的元素小于下标元素，右边的大于下标元素，因此我们只需要在递归时找到下标为k的就能直接返回了，如果下标大于k，那么递归左边，如果下标小于k，那么递归右边； 最坏时间复杂度是O(N²)，平均时间复杂度是O(N)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 最后一个参数表示我们要找的是下标为k-1的数</span><br>        <span class="hljs-keyword">return</span> quickSearch(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] quickSearch(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> partition(nums, lo, hi);<br>        <span class="hljs-keyword">if</span> (j == k) &#123;<br>            <span class="hljs-keyword">return</span> Arrays.copyOf(nums, j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span><br>        <span class="hljs-keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="hljs-number">1</span>, k): quickSearch(nums, j + <span class="hljs-number">1</span>, hi, k);<br>    &#125;<br><br>    <span class="hljs-comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> nums[lo];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lo, j = hi + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);<br>            <span class="hljs-keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);<br>            <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[j];<br>            nums[j] = nums[i];<br>            nums[i] = t;<br>        &#125;<br>        nums[lo] = nums[j];<br>        nums[j] = v;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/#%E4%BA%8C%E3%80%81%E5%A4%A7%E6%A0%B9%E5%A0%86%E5%89%8D-k-%E5%B0%8F-/-%E5%B0%8F%E6%A0%B9%E5%A0%86%EF%BC%88%E5%89%8D-k-%E5%A4%A7,java%E4%B8%AD%E6%9C%89%E7%8E%B0%E6%88%90%E7%9A%84-priorityqueue%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%B5%B7%E6%9D%A5%E6%9C%80%E7%AE%80%E5%8D%95%EF%BC%9A">大根堆(前 K 小) &#x2F; 小根堆（前 K 大),Java中有现成的 PriorityQueue，实现起来最简单：</a></p><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p> <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou">二叉搜索树也可以 解决 TopK 问题</a></p><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p> <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E6%9C%89%E9%99%90%E6%97%B6%E7%9B%B4%E6%8E%A5%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%B0%B1%E8%A1%8C%E4%BA%86%EF%BC%9A">数据范围有限时直接计数排序就行了：</a></p><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><ol><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/">4种解法秒杀TopK（快排&#x2F;堆&#x2F;二叉搜索树&#x2F;计数排序）❤️</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>topk</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer26.树的子结构</title>
    <link href="/2022/05/08/%E5%89%91%E6%8C%87Offer26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2022/05/08/%E5%89%91%E6%8C%87Offer26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs java">执行用时：<span class="hljs-number">0</span> ms, 在所有 Java 提交中击败了<span class="hljs-number">100.00</span>%的用户<br>内存消耗：<span class="hljs-number">43.9</span> MB, 在所有 Java 提交中击败了<span class="hljs-number">9.74</span>%的用户<br></code></pre></td></tr></table></figure><p>因为使用的是dfs所以整一个内存的开销比较大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> com.roger.leetcodejava.TreeNode;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/8 10:53 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-comment">/** 约定空树不是任意一个树的子结构 */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">null</span> || B == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);<br>  &#125;<br><br>  <span class="hljs-comment">/** 以下代码太精髓了! */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>    <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注意！:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;1. 这里是&amp;&amp; 而不是 ||</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;2. 然后是左右子树分别去进行比对。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> A.val == B.val &amp;&amp; dfs(A.left, B.left) &amp;&amp; dfs(A.right, B.right);<br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeD</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>    treeNodeA.left = treeNodeB;<br>    treeNodeA.right = treeNodeC;<br>    treeNodeB.left = treeNodeD;<br>    treeNodeB.right = treeNodeE;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeF</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeG</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>    treeNodeF.left = treeNodeG;<br><br>    System.out.println(isSubStructure(treeNodeA, treeNodeF));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer16.数值的整数次方</title>
    <link href="/2022/05/07/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <url>/2022/05/07/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>解决方案1: 递归法</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.roger.leetcodejava.jianzhi.solution_16.logN的解法;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/7 7:56 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(myPow(<span class="hljs-number">0.44528</span>, <span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 因为 x^72次 = x^36 * x ^ 36 所以是一个递归的解决方案.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;然后我们通过奇 和 偶 进行递归.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">/** 处理异常case */</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? quickMul(x, N) : <span class="hljs-number">1.0</span> / quickMul(x, -N);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">quickMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> N)</span> &#123;<br>        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> quickMul(x, N / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ? result * result * x : result * result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>弊端:</p><ol><li>因为使用递归其实是会使用额外的栈空间。</li></ol><p>解决方法二: 迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.roger.leetcodejava.jianzhi.solution_16.迭代;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/8 9:07 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 实现 类似 Math.pow函数 这个递归搞不明白哭</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">/** 异常case判断 */</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">currentMul</span> <span class="hljs-operator">=</span> x;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">/* 个人这地方理解难 */</span> <br>        result *= currentMul;<br>      &#125;<br>      currentMul *= currentMul;<br>      n = n &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(myPow(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>个人感觉这个迭代比较难理解。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官:动态代理是基于什么原理</title>
    <link href="/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86/"/>
    <url>/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官:String、StringBuffer、StringBuilder有什么区别</title>
    <link href="/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><table><thead><tr><th>类型</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td>String</td><td>是<strong>Immutable</strong>的,然后它的类名是final修饰的,属性都是final. 然后因为我们经常要去操作比如修改或者增加String的内容所以我们会用到下面介绍的StringBuffer以及StringBuilder.</td><td>1. 常量的声明 <br />2.<strong>少量</strong>字符串的拼接，一定要避免使用+操作去拼接字符串,因为这样会有大量的无用中间对象，耗费空间并且执行效率低下(新建对象、回收对象需要大量的时间)</td></tr><tr><td>StringBuffer</td><td>首先基于Synchronized是<strong>线程安全</strong>的,导致有额外的性能开销所以一般推荐使用StringBuilder.</td><td><strong>多线程环境</strong> ,比如XML的解析、HTTP参数的解析</td></tr><tr><td>StringBuilder</td><td><strong>线程不安全</strong>,但是是首选的.</td><td><strong>单线程环境</strong>,SQL语句的拼接还有JSON的封装</td></tr></tbody></table><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://time.geekbang.org/column/article/7349">String、StringBuffer、StringBuilder有什么区别？</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官:请说说你理解中java的引用</title>
    <link href="/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B7%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E4%B8%ADjava%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <url>/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B7%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E4%B8%ADjava%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Java中除了基本的数据类型之外，其他的都是指向各个对象的对象引用; Java中会根据其生命周期的长短，将引用分为4类.</p><h3 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h3><table><thead><tr><th>引用类型</th><th>特点</th><th>应用场景</th></tr></thead><tbody><tr><td>强引用</td><td>我们平时的编码中,比如 Object obj &#x3D; new Object,这个就是显示的强引用，当JVM内存不足的时候如果想进行垃圾回收，宁可抛出OOM也不会对这部分的强引用做垃圾回收.我们可以在将Object obj &#x3D; null来将个obj进行垃圾回收.</td><td></td></tr><tr><td>软引用</td><td>是通过softReference实现的,比强引用的生命周期要短,当我们JVM内存不足的时候会对这个软引用的对象进行垃圾回收,并且可以配合 ReferenceQueue(后文中统一称为queue)联合使用,当我们对queue进行poll的时候如果是null,否则就是引用对象</td><td>可以用于实现内存敏感的缓存.</td></tr><tr><td>弱引用</td><td>是通过weakReference实现的,比软引用的生命周期还要短,当我们JVM进行GC的时候会优先把弱引用的对象来进行GC.这个要可以配合queue进行。</td><td>内存敏感的缓存.</td></tr><tr><td>虚引用(幻想引用)</td><td>是通过PhantomReference类实现的,无法通过虚引用来访问对象的任何属性以及函数,虚引用仅仅是提供了一种保证对象被finalize后,做某些事情的机制,如果一个对象仅仅被虚引用的话,那么它和没有任何被引用一样,在任何时候都有可能被GC,虚引用必须和queue联合使用,当GC准备回收一个对象的时候,如果发现它还有虚引用,就会在回收内存对象之前，把这个虚引用加入到与之关联的引用队列中,程序可以判断queue中是否已经加入了虚引用来,了解对象是否将要被GC如果发现程序可以当在被回收之前进行相应的处理。</br> ReferenceQueue queue &#x3D; new ReferenceQueue (); PhantomReference pr &#x3D; new PhantomReference (object, queue);</td><td>用于追踪gc，可以在程序被GC前通知用户.</td></tr></tbody></table><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://time.geekbang.org/column/article/6970">引用的特点和应用场景</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer66.构建乘积数组</title>
    <link href="/2022/05/06/%E5%89%91%E6%8C%87Offer66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <url>/2022/05/06/%E5%89%91%E6%8C%87Offer66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组🔗</a><br>先直接来一个错误解决方法:</p><p>该错误的解决方法的时间复杂度为O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/6 7:37 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] ints = constructArr(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>        System.out.println(ints);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前算法时间复杂度为n^2.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] constructArr(<span class="hljs-type">int</span>[] a) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentMulti</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j != i) &#123;<br>                    currentMulti *= a[j];<br>                &#125;<br>            &#125;<br>            result[i] = currentMulti;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上正解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/6 7:45 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] ints = constructArr(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>        System.out.println(ints);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这里采用了2个for循环 时间复杂度只有O(n);空间复杂度只有个常量级别的所以是O(1);</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] constructArr(<span class="hljs-type">int</span>[] a) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inputLength</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[inputLength];<br>        <span class="hljs-comment">/** 把每个result[i]左边的乘集得到 */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, product = <span class="hljs-number">1</span>; i &lt; inputLength; product *= a[i], i++) &#123;<br>            result[i] = product;<br>        &#125;<br>        <span class="hljs-comment">/** 我的疑问: 为什么上面是=product 下面这里是*=product. */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> inputLength - <span class="hljs-number">1</span>, product = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; product *= a[i], i--) &#123;<br>            result[i] *= product;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么你的maven打包老是出现问题</title>
    <link href="/2022/05/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/"/>
    <url>/2022/05/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><h4 id="项目层级和IDEA设置介绍"><a href="#项目层级和IDEA设置介绍" class="headerlink" title="项目层级和IDEA设置介绍:"></a>项目层级和IDEA设置介绍:</h4><p>多模块的目录层级为<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="多模块的目录层级"><br>可以看到有3个子模块，分别是dnm-business、dnm-ess4j、dnm-web. IDEA中也设置了:</p><p><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/IDEA%E9%80%92%E5%BD%92%E8%AE%BE%E7%BD%AE.png" alt="IDEA的设置"></p><h3 id="我的操作"><a href="#我的操作" class="headerlink" title="我的操作"></a>我的操作</h3><p>点击了下的clean 然后install. 然后dnm-web下的taget文件目录中运行了java -jar后的运行结果如图：<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF%E6%88%AA%E5%9B%BE.png" alt="运行结果"><br>总而言之不是缺这个就是缺那个.但是打包是正常的.</p><p>有个项目是多module进行打包的,打包后发现不是这里缺一个类，就是那边一个依赖没有打包完全。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用了maven Helper这个IDEA的插件,只要简单地进行对于标红的冲突依赖进行exclude即可，最后重新clean-package.<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E6%9C%80%E7%BB%88pom.xml%E6%B2%A1%E6%9C%89%E5%86%B2%E7%AA%81.png" alt="最终的pom.xml依赖树"></li><li>也可以通过 mvn dependency:tree -Dverbose -includes&#x3D;gid:aid看看所依赖的版本和实际用的版本对不对，gid:aid换成这个依赖的ga信息<br>例如:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs Java">➜  target mvn dependency:tree -Dverbose -Dincludes=io.springfox:springfox-boot-starter<br></code></pre></td></tr></table></figure><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E5%AE%8C%E7%BE%8E%E8%BF%90%E8%A1%8C.png" alt="完美运行"></p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
      <category>项目实践</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer30包含min函数的栈</title>
    <link href="/2022/05/05/%E5%89%91%E6%8C%87Offer30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <url>/2022/05/05/%E5%89%91%E6%8C%87Offer30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>🔗<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></p><p>通过ArrayList来实现</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/5 7:10 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;第一版代码</span><br><span class="hljs-comment"> *     &lt;p&gt;执行结果： 通过 显示详情 添加备注</span><br><span class="hljs-comment"> *     &lt;p&gt;执行用时： 110 ms , 在所有 Java 提交中击败了 5.66% 的用户 内存消耗： 43.3 MB , 在所有 Java 提交中击败了 56.68% 的用户</span><br><span class="hljs-comment"> *     通过测试用例： 19 / 19</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MinStack</span> <span class="hljs-variable">minStack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinStack</span>();<br>        minStack.push(-<span class="hljs-number">2</span>);<br>        minStack.push(<span class="hljs-number">0</span>);<br>        minStack.push(-<span class="hljs-number">3</span>);<br>        System.out.println(minStack.min());<br>        minStack.pop();<br>        System.out.println(minStack.top());<br>        System.out.println(minStack.min());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ArrayList&lt;Integer&gt; arrayList;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        arrayList.add(x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        arrayList.remove(arrayList.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> arrayList.get(arrayList.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> integer.intValue();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minValue</span> <span class="hljs-operator">=</span> arrayList.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (minValue &gt; arrayList.get(i)) &#123;<br>                minValue = arrayList.get(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 LinkedList 来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.roger.leetcodejava.jianzhi.solution_30.byLinkedList;<br><br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/5 7:28 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;为什么使用Deque 而不是直接使用Stack</span><br><span class="hljs-comment"> *     &lt;p&gt;首先因为class Stack&lt;E&gt; extends Vector&lt;E&gt; 继承自 Vector</span><br><span class="hljs-comment"> *     &lt;p&gt;Stack作为java语言的栈，是被诟病的地方，作为栈数据结构，却继承了vector，对外暴露了get(index)这样的方法，不是一种合理的实现方式，所以后来java开发提倡使用ArrayDeque</span><br><span class="hljs-comment"> *     &lt;p&gt;另外题目中有要求说调用 min、push 及 pop 的时间复杂度都是O(1) 所以有一个minStack 存放最小值</span><br><span class="hljs-comment"> *     &lt;p&gt;执行用时： 13 ms , 在所有 Java 提交中击败了 63.74% 的用户 内存消耗： 43.5 MB , 在所有 Java 提交中击败了 34.30% 的用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>  <span class="hljs-comment">/** initialize your data structure here. */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MinStack</span> <span class="hljs-variable">minStack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinStack</span>();<br>    minStack.push(-<span class="hljs-number">2</span>);<br>    minStack.push(<span class="hljs-number">0</span>);<br>    minStack.push(-<span class="hljs-number">3</span>);<br>    System.out.println(minStack.min());<br>    minStack.pop();<br>    System.out.println(minStack.top());<br>    System.out.println(minStack.min());<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; xStack;<br><br>  <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; minStack;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>    xStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    minStack.push(Integer.MAX_VALUE);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这里 Math.min(x,minStack.peek()) 是非常巧妙的 因为如果xStack pop的话 minStack也会同步pop</span><br><span class="hljs-comment">     * 并且保证了minStack的第一个元素是最小的.</span><br><span class="hljs-comment">     */</span><br>    xStack.push(x);<br>    minStack.push(Math.min(x, minStack.peek()));<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>    xStack.pop();<br>    minStack.pop();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> xStack.peek();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> minStack.peek();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer33二叉搜索树的后序遍历序列</title>
    <link href="/2022/05/04/%E5%89%91%E6%8C%87Offer33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <url>/2022/05/04/%E5%89%91%E6%8C%87Offer33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/4 9:46 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;解题思路: 概念介绍: 二叉搜索树: 左子树上的节点的值 小于 根,右子树上的节点的值 大于 根。 如何判断是否跳出递归? left&gt;right? left right end</span><br><span class="hljs-comment"> *     左子树 右子树 根</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> verifyPostorder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;);<br>    System.out.println(b);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>    <span class="hljs-keyword">return</span> mainCore(postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mainCore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postOrder, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">/** 跳出递归的条件 */</span><br>    <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> start;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> postOrder[end];<br>    <span class="hljs-comment">// 找到第一个右子树的节点</span><br>    <span class="hljs-keyword">for</span> (; count &lt; postOrder.length; count++) &#123;<br>      <span class="hljs-keyword">if</span> (postOrder[count] &gt;= head) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> count; i &lt; end; i++) &#123;<br>      <span class="hljs-keyword">if</span> (postOrder[i] &lt;= head) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">/** mark! 这里的end需要-1 */</span><br>    <span class="hljs-keyword">return</span> mainCore(postOrder, start, count - <span class="hljs-number">1</span>) &amp;&amp; mainCore(postOrder, count, end - <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>请写出一个死锁的demo</title>
    <link href="/2022/05/04/%E8%AF%B7%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84demo/"/>
    <url>/2022/05/04/%E8%AF%B7%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84demo/</url>
    
    <content type="html"><![CDATA[<h3 id="先写一个通过Synchronized造成死锁的demo"><a href="#先写一个通过Synchronized造成死锁的demo" class="headerlink" title="先写一个通过Synchronized造成死锁的demo."></a>先写一个通过Synchronized造成死锁的demo.</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SynchronizedTest</span> <span class="hljs-variable">synchronizedTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>    synchronizedTest.test();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (numA) &#123;<br>                  System.out.println(<span class="hljs-string">&quot;AAA&quot;</span>);<br>                  <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">3</span> * <span class="hljs-number">1000</span>);<br>                  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                  &#125;<br>                  <span class="hljs-keyword">synchronized</span> (numB) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;CCC&quot;</span>);<br>                  &#125;<br>                &#125;<br>              &#125;<br>            &#125;,<br>            <span class="hljs-string">&quot;A&quot;</span>);<br>    a.start();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (numB) &#123;<br>                  System.out.println(<span class="hljs-string">&quot;BBB&quot;</span>);<br>                  <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">3</span> * <span class="hljs-number">1000</span>);<br>                  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                  &#125;<br>                  <span class="hljs-keyword">synchronized</span> (numA) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;DDD&quot;</span>);<br>                  &#125;<br>                &#125;<br>              &#125;<br>            &#125;,<br>            <span class="hljs-string">&quot;B&quot;</span>);<br>    b.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="那么如何感知是否死锁了呢？"><a href="#那么如何感知是否死锁了呢？" class="headerlink" title="那么如何感知是否死锁了呢？"></a>那么如何感知是否死锁了呢？</h3><ol><li>可以通过dump线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  ~ jps<br><span class="hljs-number">16342</span> Jps<br><span class="hljs-number">2281</span><br><span class="hljs-number">16169</span> Launcher<br><span class="hljs-number">16170</span> SynchronizedTest<br></code></pre></td></tr></table></figure><p>然后通过jstack发现了以下内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java">Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;B&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000013a80b620</span> (object <span class="hljs-number">0x000000076ab33a68</span>, a java.lang.Integer),<br>  which is held by <span class="hljs-string">&quot;A&quot;</span><br><span class="hljs-string">&quot;A&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000013a80deb0</span> (object <span class="hljs-number">0x000000076ab33a78</span>, a java.lang.Integer),<br>  which is held by <span class="hljs-string">&quot;B&quot;</span><br><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;B&quot;</span>:<br>at roger.com.javafundament.deadLock.SynchronizedTest$<span class="hljs-number">2.</span>run(SynchronizedTest.java:<span class="hljs-number">52</span>)<br>- waiting to lock &lt;<span class="hljs-number">0x000000076ab33a68</span>&gt; (a java.lang.Integer)<br>- locked &lt;<span class="hljs-number">0x000000076ab33a78</span>&gt; (a java.lang.Integer)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-string">&quot;A&quot;</span>:<br>at roger.com.javafundament.deadLock.SynchronizedTest$<span class="hljs-number">1.</span>run(SynchronizedTest.java:<span class="hljs-number">31</span>)<br>- waiting to lock &lt;<span class="hljs-number">0x000000076ab33a78</span>&gt; (a java.lang.Integer)<br>- locked &lt;<span class="hljs-number">0x000000076ab33a68</span>&gt; (a java.lang.Integer)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><h3 id="避免死锁的几个常见方法"><a href="#避免死锁的几个常见方法" class="headerlink" title="避免死锁的几个常见方法"></a>避免死锁的几个常见方法</h3><p>1避免同一个线程或者多个锁.</p><ol start="2"><li>避免在一个线程在锁内占用多个资源,尽量保证每个锁只占用一个资源.</li><li>尝试使用定时锁,使用lock.tryLock(timeout)来替代内部锁的机制.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTryLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SynchronizedTryLockTest</span> <span class="hljs-variable">synchronizedTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTryLockTest</span>();<br>        synchronizedTest.test();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lockA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lockB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">if</span> (lockA.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>                                System.out.println(<span class="hljs-string">&quot;AAA&quot;</span>);<br>                                <span class="hljs-keyword">if</span> (lockB.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>                                    System.out.println(<span class="hljs-string">&quot;BBB&quot;</span>);<br>                                &#125;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;)<br>                .start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">if</span> (lockA.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>                                System.out.println(<span class="hljs-string">&quot;CCC&quot;</span>);<br>                                <span class="hljs-keyword">if</span> (lockB.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>                                    System.out.println(<span class="hljs-string">&quot;DDD&quot;</span>);<br>                                &#125;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;)<br>                .start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>对于数据库锁,加锁和解锁必须在同一个数据库连接里面,否则会出现解锁失效的情况.</li></ol><h3 id="github-源码链接🔗"><a href="#github-源码链接🔗" class="headerlink" title="github 源码链接🔗"></a>github 源码链接🔗</h3><ol><li><a href="https://github.com/ZuccRoger/JavaFundament/blob/master/src/main/java/roger/com/javafundament/deadLock/SynchronizedTest.java">SynchronizedTest</a></li><li><a href="https://github.com/ZuccRoger/JavaFundament/blob/master/src/main/java/roger/com/javafundament/deadLock/SynchronizedTryLockTest.java">SynchronizedTryLockTest</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer32.3从上到下打印二叉树</title>
    <link href="/2022/05/04/%E5%89%91%E6%8C%87Offer32-3%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/04/%E5%89%91%E6%8C%87Offer32-3%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">题目链接</a></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    ArrayList&lt;List&lt;Integer&gt;&gt; resultList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">/** 空树 */</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> resultList;<br>    &#125;<br>    LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>      ArrayList&lt;Integer&gt; layerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-comment">/** 个人认为这个分层是比较难的。不知道如何处理 */</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>      <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">firstNode</span> <span class="hljs-operator">=</span> queue.poll();<br>        layerList.add(firstNode.val);<br>        <span class="hljs-keyword">if</span> (firstNode.left != <span class="hljs-literal">null</span>) &#123;<br>          queue.add(firstNode.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (firstNode.right != <span class="hljs-literal">null</span>) &#123;<br>          queue.add(firstNode.right);<br>        &#125;<br>        size--;<br>      &#125;<br>      resultList.add(layerList);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; resultList.size(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        Collections.reverse(resultList.get(i));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultList;<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer32.2从上到下打印二叉树</title>
    <link href="/2022/05/03/%E5%89%91%E6%8C%87Offer32-2%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/03/%E5%89%91%E6%8C%87Offer32-2%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(root);<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>      ArrayList&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br>      <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmpNode</span> <span class="hljs-operator">=</span> queue.remove();<br>        itemList.add(tmpNode.val);<br>        <span class="hljs-keyword">if</span> (tmpNode.left != <span class="hljs-literal">null</span>) &#123;<br>          queue.add(tmpNode.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (tmpNode.right != <span class="hljs-literal">null</span>) &#123;<br>          queue.add(tmpNode.right);<br>        &#125;<br>        len--;<br>      &#125;<br>      lists.add(itemList);<br>    &#125;<br>    <span class="hljs-keyword">return</span> lists;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer32.1从上到下打印二叉树</title>
    <link href="/2022/05/02/%E5%89%91%E6%8C%87Offer32-1%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/02/%E5%89%91%E6%8C%87Offer32-1%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目: <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指Offer32.1从上到下打印二叉树</a><br>代码块为:</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>    <span class="hljs-comment">/** 防止异常case */</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">/** bfs 需要一个额外变量 去存储元素 */</span><br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>      <span class="hljs-comment">/** 记得这里需要用remove 而不是poll 因为 poll 会返回null 但是remove不会 */</span><br>      root = queue.remove();<br>      list.add(root.val);<br>      <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>        queue.add(root.left);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>        queue.add(root.right);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">/** 这里的list 转 int[]数组非常巧妙 */</span><br>    <span class="hljs-keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer13机器人的运动范围</title>
    <link href="/2022/05/02/%E5%89%91%E6%8C%87Offer13%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2022/05/02/%E5%89%91%E6%8C%87Offer13%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>剪绳子(I)</title>
    <link href="/2022/05/02/%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <url>/2022/05/02/%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>题目: <a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a><br>代码块为:</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/** 处理特殊case */</span><br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">/** 开启dp mode */</span><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &lt;= n; i++) &#123;<br>  <span class="hljs-comment">/** 此处要保证j从下标1开始到 i/2 因为是对称性的 比如 1+3 和 2+2 最后3+1其实 j的范围是 i/2 即可 */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= (i / <span class="hljs-number">2</span>); j++) &#123;<br>    <span class="hljs-comment">/** 此处要保证 j 以及 i-j是俩下标。 */</span><br>    dp[i] = Math.max(dp[i], dp[j] * dp[i - j]);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何注册一个bean</title>
    <link href="/2022/05/01/%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AAbean/"/>
    <url>/2022/05/01/%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AAbean/</url>
    
    <content type="html"><![CDATA[<p>通过BeanDefinition以及外部的单体对象来注册</p><p>三个方向</p><ol><li>注解<ul><li>@Bean</li><li>@Component</li><li>@Import</li><li></li></ul></li><li>API</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webClient扫盲</title>
    <link href="/2022/05/01/webClient/"/>
    <url>/2022/05/01/webClient/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在spring5之前我们知道有http client 以及 web client两种,毫无意外都是同步执行的,然而webclient是异步回调的.</p><h4 id="发送请求的种类"><a href="#发送请求的种类" class="headerlink" title="发送请求的种类"></a>发送请求的种类</h4><ol><li>apache httpclient</li><li>webclient</li><li>resttemplate</li></ol><table><thead><tr><th></th><th>apache httpclient</th><th>resttemplate</th><th>webclient</th></tr></thead><tbody><tr><td>代码简洁程度</td><td>低</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://note.youdao.com/yws/res/9441/WEBRESOURCE1403f079524010b181d7f9527f979a6f" alt="image.png"><br>代码量大</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>1. </p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>非阻塞系统(non-blocking servers)</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li>创建</li></ol><ul><li>WebClient.create()<figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">WebClient.<span class="hljs-built_in">create</span>()<br><br>WebClient.<span class="hljs-built_in">create</span>(String baseUrl)<br></code></pre></td></tr></table></figure></li><li>WebClient.builder()<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">uriBuilderFactory:</span> Customized UriBuilderFactory <span class="hljs-keyword">to</span> use <span class="hljs-keyword">as</span> a base URL.<br><br><span class="hljs-symbol">defaultUriVariables:</span> <span class="hljs-keyword">default</span> values <span class="hljs-keyword">to</span> use <span class="hljs-keyword">when</span> expanding URI templates.<br><br><span class="hljs-symbol">defaultHeader:</span> Headers <span class="hljs-keyword">for</span> every request.<br><br><span class="hljs-symbol">defaultCookie:</span> Cookies <span class="hljs-keyword">for</span> every request.<br><br><span class="hljs-symbol">defaultRequest:</span> Consumer <span class="hljs-keyword">to</span> customize every request.<br><br><span class="hljs-symbol">filter:</span> Client filter <span class="hljs-keyword">for</span> every request.<br><br><span class="hljs-symbol">exchangeStrategies:</span> HTTP message reader/writer customizations.<br><br><span class="hljs-symbol">clientConnector:</span> HTTP client library settings.<br></code></pre></td></tr></table></figure></li></ul><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><strong>retrieve()</strong> 定义如何去提取响应结果.<br>有三种</li></ul><ol><li>toEntity</li><li>bodyToMono</li><li>bodyToFlux<br>定制错误类型<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Mono&lt;Person&gt; result = client.get<span class="hljs-literal">()</span><br>        .uri(<span class="hljs-string">&quot;/persons/&#123;id&#125;&quot;</span>, id).accept(MediaType.APPLICATION_JSON)<br>        .retrieve<span class="hljs-literal">()</span><br>        .on<span class="hljs-constructor">Status(HttpStatus::<span class="hljs-params">is4xxClientError</span>, <span class="hljs-params">response</span> -&gt; <span class="hljs-operator">...</span>)</span><br>        .on<span class="hljs-constructor">Status(HttpStatus::<span class="hljs-params">is5xxServerError</span>, <span class="hljs-params">response</span> -&gt; <span class="hljs-operator">...</span>)</span><br>        .body<span class="hljs-constructor">ToMono(Person.<span class="hljs-params">class</span>)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>exchange()</li><li></li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">1</span>: 参考资料 https://elim<span class="hljs-number">168</span>.github.io/spring/bean/<span class="hljs-number">31</span>.Spring<span class="hljs-variable">%E4</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%8</span>BWebClient<span class="hljs-variable">%E4</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%8</span>B<span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%8</span>D.html<br></code></pre></td></tr></table></figure><h4 id="我的疑问"><a href="#我的疑问" class="headerlink" title="我的疑问"></a>我的疑问</h4><ol><li>这个webclient需要配置一个http连接池吗？</li><li>Jetty vs  Netty</li></ol><h4 id="项目中遇到的困难"><a href="#项目中遇到的困难" class="headerlink" title="项目中遇到的困难"></a>项目中遇到的困难</h4><ol><li>302的时候无法捕获到这个cookie</li></ol><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client">spring.io Web Clinent</a></li><li><a href="https://www.baeldung.com/spring-webclient-resttemplate">link</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP常见错误</title>
    <link href="/2022/05/01/AOP%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <url>/2022/05/01/AOP%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>AOP本质上是一个代理模式<br>Spring AOP 的底层是动态代理。而创建代理的方式有两种，JDK 的方式和 CGLIB 的方式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>详述bean生命周期</title>
    <link href="/2022/05/01/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/05/01/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><ol><li></li></ol><p>问题解决：<br>即 Spring 初始化单例类的一般过程，基本都是 getBean()-&gt;doGetBean()-&gt;getSingleton()，如果发现 Bean 不存在，则调用 createBean()-&gt;doCreateBean() 进行实例化。</p><h3 id="class到Bean中间经历了哪些生命周期什么？"><a href="#class到Bean中间经历了哪些生命周期什么？" class="headerlink" title="class到Bean中间经历了哪些生命周期什么？"></a>class到Bean中间经历了哪些生命周期什么？</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>元信息配置阶段</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>notify&amp;wait实现生产者消费者模型</title>
    <link href="/2022/04/30/notify&amp;wait%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/30/notify&amp;wait%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/4/19 8:06 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Producer.class);<br>  <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">(Queue&lt;Integer&gt; queue, <span class="hljs-type">int</span> maxSize, String threadName)</span> &#123;<br>    <span class="hljs-built_in">super</span>(threadName);<br>    <span class="hljs-built_in">this</span>.queue = queue;<br>    <span class="hljs-built_in">this</span>.maxSize = maxSize;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.run();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">2</span>));<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>      <span class="hljs-comment">/** 在条件判断之前给共享资源加锁 */</span><br>      <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>        <span class="hljs-keyword">while</span> (queue.size() == maxSize) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            logger.info(<span class="hljs-string">&quot;消息队列已满: 生产者线程调用wait方法进入等待状态 ...&quot;</span>);<br>            queue.wait();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">messageId</span> <span class="hljs-operator">=</span> pc++;<br>        logger.info(<span class="hljs-string">&quot;生产消息:&#123;&#125; &quot;</span>, messageId);<br>        queue.add(messageId);<br>        queue.notify();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/4/19 8:13 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Consumer.class);<br>  <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(Queue&lt;Integer&gt; queue, String threadName)</span> &#123;<br>    <span class="hljs-built_in">super</span>(threadName);<br>    <span class="hljs-built_in">this</span>.queue = queue;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.run();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>        <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            logger.info(<span class="hljs-string">&quot;消息队列为空: 消费者线程调用wait方法进入等待状态 ...&quot;</span>);<br>            queue.wait();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>        logger.info(<span class="hljs-string">&quot;消费信息:&#123;&#125;&quot;</span>, queue.remove());<br>        queue.notify();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/4/19 8:46 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Launch</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(queue, maxSize, <span class="hljs-string">&quot;producer-thread&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(queue, <span class="hljs-string">&quot;consumer-thread&quot;</span>).start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行截图:<br><img src="http://pfp.ps.netease.com/kmspvt/file/625e4fc4935599814c6250b2Th1x8iSc01?sign=1m7oZcDS-4WGCnZHfhOFX8Lg0lw=&expire=1651311214" alt="image.png"><br>源码自取:<br><a href="https://github.com/ZuccRoger/JavaFundament">https://github.com/ZuccRoger/JavaFundament</a><br>包路径为：<a href="https://github.com/ZuccRoger/JavaFundament/tree/master/src/main/java/roger/com/javafundament/produceAndConsume/notifyAndWait">https://github.com/ZuccRoger/JavaFundament/tree/master/src/main/java/roger/com/javafundament/produceAndConsume/notifyAndWait</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring中如何自己去实现一个starter</title>
    <link href="/2022/04/30/spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAstarter/"/>
    <url>/2022/04/30/spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAstarter/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是自动装配"><a href="#什么是自动装配" class="headerlink" title="什么是自动装配"></a>什么是自动装配</h3><p>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</p><h3 id="spring是如何实现自动装配的？"><a href="#spring是如何实现自动装配的？" class="headerlink" title="spring是如何实现自动装配的？"></a>spring是如何实现自动装配的？</h3><p>springboot的自动配置是基于spring factories机制实现的，这是一种服务发现机制，类似Java SPI。 spring会自动扫描所有jar包类路径下的META-INF&#x2F;spring.factories文件，读取其中的类型并进项实例化。<br>spring.factories文件中的内容实际上就是要导入的接口名和实现类组成的kv对，key为文件中定义的一些标识工厂类，value就是能自动配置的一些工厂实现的类。   在自动装配时，其实就是去加载AutoConfiguration类和实现类，<br>在加载自动配置类的时候，并不是将spring.factories的配置全部加载进来，而是通过@Conditional等注解的判断进行动态加载，只有当容器满足了注解中的条件的时候，才会将类加载到容器中</p><hr><p>偷来的八股文：<br>自动装配依托@Import的强大功能和spring的SPI机制。通过SPI机制发现类，通过@Import将类注册到spring中。@SpringBootApplication这个注解时组合注解里面包含自动扫描注解，里面包含一个EnableAutoConfiguration注解，这个注解作用是去寻找每个jar包里面的META-INF&#x2F;spring.factories文件，之后将文件里面的类全部实例化。<br>每个需要自动装配的模块都需要编写一个AutoConfiguration类，这些AutoConfiguration类的原理大概是通过@Import注解将其属性类Properties全部到注册spring容器中，属性类通过注解@ConfigurationProperties从配置文件里面取到配置值。之后将关键的类注册为bean自动注入属性类进行初始化完成自动装配的功能。</p><h4 id="细分相关知识如下："><a href="#细分相关知识如下：" class="headerlink" title="细分相关知识如下："></a>细分相关知识如下：</h4><p>我们知道</p><figure class="highlight less"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span> = <span class="hljs-variable">@SpringBootConfiguration</span>+<span class="hljs-variable">@EnableAutoConfiguration</span>+<span class="hljs-variable">@ComponentScan</span><br></code></pre></td></tr></table></figure><p>我们要重点关注这个@EnableAutoConfiguration.<br>看到 EnableAutoConfiguration.class 文件有个@Import({AutoConfigurationImportSelector.class})</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><ol><li>第一步会去看这个<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.png" alt="image.png"><br>可以看到默认是spring.boot.enableautoconfiguration的值默认是true。</li><li>得到排除的依赖项<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/%E5%BE%97%E5%88%B0%E6%8E%92%E9%99%A4%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9.png" alt="image"></li><li>得到配置内容<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/%E5%BE%97%E5%88%B0factories%E4%B8%AD%E7%9A%84bean.png" alt="img"></li></ol><h3 id="如何自己实现一个starter？"><a href="#如何自己实现一个starter？" class="headerlink" title="如何自己实现一个starter？"></a>如何自己实现一个starter？</h3><ol><li>在resources&#x2F;META-INF中新建spring.factories文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>com.roger.demospringbootstarter.config.DemoConfig<br></code></pre></td></tr></table></figure></li><li>在这个EnableAutoConfiguration的属性所对应的java文件中写入自己想装配的bean.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/4/27 10:21 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(DemoConfig.class);<br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demoService</span><span class="hljs-params">()</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;我是自动装配进来的&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在外部如何引用？<br>本地打包的时候可以直接点击mvn clean pakcage.然后会在本地的maven仓库中出现该jar文件。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.roger<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="如何自动配置是否生效"><a href="#如何自动配置是否生效" class="headerlink" title="如何自动配置是否生效"></a>如何自动配置是否生效</h3><p>启动的时候可以增加-Ddebug参数.<br>会有以下4种形式的输出</p><table><thead><tr><th>类型</th><th>意义</th></tr></thead><tbody><tr><td>Positive matches</td><td>@Conditional条件为真，配置类被Spring容器加载</td></tr><tr><td>Negative matches</td><td>@Conditional条件为假，配置类未被Spring容器加载</td></tr><tr><td>Exclusions</td><td>应用端明确排除加载配置</td></tr><tr><td>Unconditional classes</td><td>自动配置类不包含任何类级别的条件，也就是说，类始终会被自动加载。</td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Unconditional classes:<br>----------------------<br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.ConfigurationPropertiesAutoConfiguration</span><br><br>    com<span class="hljs-selector-class">.roger</span><span class="hljs-selector-class">.demospringbootstarter</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.DemoConfig</span><br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.LifecycleAutoConfiguration</span><br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.PropertyPlaceholderAutoConfiguration</span><br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.availability</span><span class="hljs-selector-class">.ApplicationAvailabilityAutoConfiguration</span><br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.info</span>.ProjectInfoAutoConfiguration<br></code></pre></td></tr></table></figure><p>最终在输出的命令行中我看见了    com.roger.demospringbootstarter.config.DemoConfig 该Bean.</p><h3 id="最后的效果"><a href="#最后的效果" class="headerlink" title="最后的效果"></a>最后的效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">30</span> <span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">06.150</span>  INFO <span class="hljs-number">56979</span> --- [           main] r.c.j.JavaFundamentApplication           : Starting JavaFundamentApplication using Java <span class="hljs-number">1.8</span><span class="hljs-number">.0_312</span> on YolandadeMacBook-Air.local with PID <span class="hljs-number">56979</span> (/Users/yolanda/code/javaProject/javaFundament/target/classes started by yolanda in /Users/yolanda/code/javaProject/javaFundament)<br><span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">30</span> <span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">06.152</span>  INFO <span class="hljs-number">56979</span> --- [           main] r.c.j.JavaFundamentApplication           : No active profile set, falling back to <span class="hljs-number">1</span> <span class="hljs-keyword">default</span> profile: <span class="hljs-string">&quot;default&quot;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">30</span> <span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">09.567</span>  INFO <span class="hljs-number">56979</span> --- [           main] c.r.d.config.DemoConfig                  : 我是自动装配进来的<br>asdas dlksa dsj kldsja kldsaj klasjdl ksaj<br><span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">30</span> <span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">09.656</span>  INFO <span class="hljs-number">56979</span> --- [           main] r.c.j.JavaFundamentApplication           : Started JavaFundamentApplication in <span class="hljs-number">3.71</span> seconds (JVM running <span class="hljs-keyword">for</span> <span class="hljs-number">4.835</span>)<br>Disconnected from the target VM, address: <span class="hljs-string">&#x27;127.0.0.1:61225&#x27;</span>, transport: <span class="hljs-string">&#x27;socket&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="源代码自取"><a href="#源代码自取" class="headerlink" title="源代码自取"></a>源代码自取</h3><ol><li><a href="https://github.com/ZuccRoger/AutoConfigaration">https://github.com/ZuccRoger/AutoConfigaration</a></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html">Javaguide</a></li><li><a href="https://time.geekbang.org/course/detail/100023501-87617">极客时间-了解自动装配实现原理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
