<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Docker学习记录</title>
    <link href="/2022/05/16/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/05/16/Docker%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>镜像和容器的关系<ol><li>镜像和容器可以类比为类和对象，容器可以被创建、启动、停止、删除和暂停。</li></ol></li></ol><h3 id="实战经历"><a href="#实战经历" class="headerlink" title="实战经历"></a>实战经历</h3><ol><li><p>如何进入容器？</p><ol><li><p>第一阶段: 首先需要把镜像启动起来. </p></li><li><p>&#96;&#96;&#96;sh<br>docker run -it –name lhepMaven hub.fuxi.netease.com&#x2F;qa-web&#x2F;jenkins-maven:3.6</p><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><pre><code class="hljs bash"><br>3. 第二阶段: 通过容器ID进入 或者 NAMES 进行 (其中names可以通过docker ps -a查看到)<br><br>   ```sh<br>   ➜  /etc docker ps -a<br>   CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS                  PORTS                                                                     NAMES<br>   98d6fde314ce   bitnami/kafka   <span class="hljs-string">&quot;/opt/bitnami/script…&quot;</span>   15 seconds ago   Up Less than a second   0.0.0.0:9002-&gt;9002/tcp, :::9002-&gt;9002/tcp, 9092/tcp                       kafka<br>   6d90e0c7f652   zookeeper       <span class="hljs-string">&quot;/docker-entrypoint.…&quot;</span>   5 minutes ago    Up 5 minutes            2888/tcp, 3888/tcp, 0.0.0.0:2181-&gt;2181/tcp, :::2181-&gt;2181/tcp, 8080/tcp   zookeeper<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 第一种 容器ID进入</span><br>docker <span class="hljs-built_in">exec</span> -it 8x9zc89asd /bin/bash <br><span class="hljs-comment"># 第二种 NAMES 进行</span><br>docker <span class="hljs-built_in">exec</span> -it zookeeper /bin/bash<br></code></pre></td></tr></table></figure></li></ol></li><li></li><li><p>Docker-compose.yml</p><ol><li>如何启动</li></ol></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>rocketMQ学习笔记</title>
    <link href="/2022/05/16/rocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/16/rocketMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h3><ol><li>拉取镜像</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs shell">docker pull rocketmqinc/rocketmq<br></code></pre></td></tr></table></figure><ol start="2"><li>启动namesrv服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run \<br>--restart=always \<br>--name rmqbroker \<br>--link rmqnamesrv:namesrv \<br>-p 10911:10911 \<br>-p 10909:10909 \<br>-v  /tmp/rocketmq/data/broker/logs:/root/logs \<br>-v  /tmp/rocketmq/data/broker/store:/root/store \<br>-v /tmp/rocketmq/conf/broker.conf:/opt/rocketmq-4.4.0/conf/broker.conf \<br>-e &quot;NAMESRV_ADDR=namesrv:9876&quot; \<br>-e &quot;MAX_POSSIBLE_HEAP=200000000&quot; \<br>rocketmqinc/rocketmq \<br>sh mqbroker -c /opt/rocketmq-4.4.0/conf/broker.conf <br></code></pre></td></tr></table></figure><h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><h3 id="我遇到的问题以及如何解决的"><a href="#我遇到的问题以及如何解决的" class="headerlink" title="我遇到的问题以及如何解决的"></a>我遇到的问题以及如何解决的</h3><ol><li><p>当我通过docker-compose去启动相应的rmq的时候出现了下面的情况。</p><ol><li><div class="code-wrapper"><pre><code class="sh">➜  rocketmq docker-compose upDocker Compose is now in the Docker CLI, try `docker compose up`Starting rmqnamesrv ... doneStarting rmqbroker  ... doneStarting rmqconsole ... doneAttaching to rmqnamesrv, rmqconsole, rmqbrokerrmqnamesrv    | OpenJDK 64-Bit Server VM warning: Using the DefNew young collector with the CMS collector is deprecated and will likely be removed in a future releasermqnamesrv    | OpenJDK 64-Bit Server VM warning: UseCMSCompactAtFullCollection is deprecated and will likely be removed in a future release.rmqbroker     | ======================================rmqbroker     | -server -Xms994M -Xmx994M -Xmn248M -XX:+UseG1GC -XX:G1HeapRegionSize=16m -XX:G1ReservePercent=25 -XX:InitiatingHeapOccupancyPercent=30 -XX:SoftRefLRUPolicyMSPerMB=0 -XX:SurvivorRatio=8 -verbose:gc -Xloggc:/dev/shm/mq_gc_%p.log -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCApplicationStoppedTime -XX:+PrintAdaptiveSizePolicy -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=5 -XX:GCLogFileSize=30m -XX:-OmitStackTraceInFastThrow -XX:+AlwaysPreTouch -XX:MaxDirectMemorySize=994M -XX:-UseLargePages -XX:-UseBiasedLocking -Djava.ext.dirs=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.275.b01-0.el7_9.x86_64/jre/lib/ext:/home/rocketmq/rocketmq-4.8.0/bin/../lib -server -Xms128m -Xmx128m -Xmn128m -cp .:/home/rocketmq/rocketmq-4.8.0/bin/../conf:rmqconsole    | 02:11:59,486 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback.groovy]rmqconsole    | 02:11:59,489 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Could NOT find resource [logback-test.xml]rmqconsole    | 02:11:59,491 |-INFO in ch.qos.logback.classic.LoggerContext[default] - Found resource [logback.xml] at [jar:file:/app.jar!/BOOT-INF/classes!/logback.xml]rmqconsole    | 02:11:59,645 |-INFO in ch.qos.logback.core.joran.spi.ConfigurationWatchList@1b2c6ec2 - URL [jar:file:/app.jar!/BOOT-INF/classes!/logback.xml] is not of type filermqconsole    | 02:12:00,096 |-INFO in ch.qos.logback.classic.joran.action.ConfigurationAction - debug attribute not setrmqconsole    | 02:12:00,126 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - About to instantiate appender of type [ch.qos.logback.core.ConsoleAppender]rmqconsole    | 02:12:00,223 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Naming appender as [STDOUT]rmqconsole    | 02:12:00,289 |-INFO in ch.qos.logback.core.joran.action.NestedComplexPropertyIA - Assuming default type [ch.qos.logback.classic.encoder.PatternLayoutEncoder] for [encoder] propertyrmqconsole    | 02:12:00,687 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - About to instantiate appender of type [ch.qos.logback.core.rolling.RollingFileAppender]rmqconsole    | 02:12:00,703 |-INFO in ch.qos.logback.core.joran.action.AppenderAction - Naming appender as [FILE]rmqconsole    | 02:12:00,885 |-INFO in c.q.l.core.rolling.TimeBasedRollingPolicy@1323165413 - No compression will be usedrmqconsole    | 02:12:00,896 |-INFO in c.q.l.core.rolling.TimeBasedRollingPolicy@1323165413 - Will use the pattern /root/logs/consolelogs/rocketmq-console-%d&#123;yyyy-MM-dd&#125;.%i.log for the active filermqconsole    | 02:12:00,920 |-INFO in ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP@70177ecd - The date pattern is &#39;yyyy-MM-dd&#39; from file name pattern &#39;/root/logs/consolelogs/rocketmq-console-%d&#123;yyyy-MM-dd&#125;.%i.log&#39;.rmqconsole    | 02:12:00,920 |-INFO in ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP@70177ecd - Roll-over at midnight.rmqconsole    | 02:12:00,933 |-INFO in ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP@70177ecd - Setting initial period to Mon May 16 02:10:01 UTC 2022rmqconsole    | 02:12:00,936 |-WARN in ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP@70177ecd - SizeAndTimeBasedFNATP is deprecated. Use SizeAndTimeBasedRollingPolicy insteadrmqconsole    | 02:12:00,946 |-INFO in ch.qos.logback.core.joran.action.NestedComplexPropertyIA - Assuming default type [ch.qos.logback.classic.encoder.PatternLayoutEncoder] for [encoder] propertyrmqconsole    | 02:12:00,962 |-INFO in ch.qos.logback.core.rolling.RollingFileAppender[FILE] - Active log file name: /root/logs/consolelogs/rocketmq-console.logrmqconsole    | 02:12:00,962 |-INFO in ch.qos.logback.core.rolling.RollingFileAppender[FILE] - File property is set to [/root/logs/consolelogs/rocketmq-console.log]rmqconsole    | 02:12:00,967 |-INFO in ch.qos.logback.classic.joran.action.RootLoggerAction - Setting level of ROOT logger to INFOrmqconsole    | 02:12:00,967 |-INFO in ch.qos.logback.core.joran.action.AppenderRefAction - Attaching appender named [STDOUT] to Logger[ROOT]rmqconsole    | 02:12:00,970 |-INFO in ch.qos.logback.core.joran.action.AppenderRefAction - Attaching appender named [FILE] to Logger[ROOT]rmqconsole    | 02:12:00,970 |-INFO in ch.qos.logback.classic.joran.action.ConfigurationAction - End of configuration.rmqconsole    | 02:12:00,972 |-INFO in ch.qos.logback.classic.joran.JoranConfigurator@1e80bfe8 - Registering current configuration as safe fallback pointrmqconsole    |rmqconsole    | qemu: uncaught target signal 11 (Segmentation fault) - core dumpedrmqconsole    | Segmentation faultrmqconsole exited with code 139rmqnamesrv    | The Name Server boot success. serializeType=JSONrmqbroker     | The broker[broker-a, 172.19.0.4:10911] boot success. serializeType=JSON and name server is rmqnamesrv:9876</code></pre></div></li></ol></li><li></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="(https://github.com/apache/rocketmq/blob/master/docs/cn/RocketMQ_Example.md)">官方快速入门</a></li><li><a href="https://blog.csdn.net/ming19951224/article/details/109063041">手把手带你启动rmq</a></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>rocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka 3.x 学习笔记</title>
    <link href="/2022/05/15/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/05/15/kafka%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>分布式</strong>   的事件流平台， 被数千家用于高性能的数据管道、流分析、数据集成和关键任务应用。  基于<strong>发布&#x2F;订阅</strong>模式的<strong>消息队列</strong>,</p><h3 id="传统消息队列应用场景"><a href="#传统消息队列应用场景" class="headerlink" title="传统消息队列应用场景"></a>传统消息队列应用场景</h3><ol><li>缓存&#x2F;消峰</li><li>解耦</li><li>异步通信</li></ol><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>​kafka需要配合zookeeper联合使用,所以为了方便安装部署直接上docker-compose.yml</p><p>​可以看一下这篇文章<a href="https://segmentfault.com/a/1190000021746086">利用docker和docker-compose部署单机kafka</a></p><div class="code-wrapper"><pre><code class="hljs">#### 遇到的问题</code></pre></div><ol><li><div class="code-wrapper"><pre><code class="hljs">java.net.SocketTimeoutException: Failed to connect within 30000 mskafka_1      | at kafka.controller.RequestSendThread.brokerReady(ControllerChannelManager.scala:292)kafka_1      | at kafka.controller.RequestSendThread.doWork(ControllerChannelManager.scala:245)kafka_1      | at kafka.utils.ShutdownableThread.run(ShutdownableThread.scala:96)</code></pre></div><ol><li></li></ol></li></ol><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
      <category>kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列调研</title>
    <link href="/2022/05/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%B0%83%E7%A0%94/"/>
    <url>/2022/05/15/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E8%B0%83%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​消息队列是消息的传输过程中保存信息的容器，用于接受消息并以文件的方式存储，一个消息队列可以被一个或者多个消息者消费。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>​在大数据里面里面采用Kafka作为消息队列，在我们的JavaEE中会主要啊次用RabbitMq、RocketMQ等。</p><h3 id="对比分析"><a href="#对比分析" class="headerlink" title="对比分析"></a>对比分析</h3><p>​ <a href="https://so.csdn.net/so/search?q=ActiveMQ&spm=1001.2101.3001.7020">ActiveMQ</a> 5.x 维护越来越少，较少在大规模吞吐的场景中使用所以不做讨论。</p><table><thead><tr><th>–</th><th>apache&#x2F;Kafa</th><th align="left">RabbitMQ</th><th>apache&#x2F;RocketMQ</th></tr></thead><tbody><tr><td>GitHub star</td><td>21.9k</td><td align="left">9.5k</td><td>17.2k</td></tr><tr><td>特点</td><td><strong>它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台</strong>，它同时也是一款开源的基于发布订阅模式的消息引擎系统。</td><td align="left"></td><td>它是纯 Java 开发，<strong>具有高性能、高可靠、高实时、适合大规模分布式系统应用的特点</strong></td></tr><tr><td>优点</td><td>1. 高吞吐、低延迟<br />2.高伸缩性<br />3.高稳定性<br />4.持久性、可靠性、可回溯性<br />5. 消息有序<br />6.有优秀的第三方kafka web界面</td><td align="left">1. 支持几乎所有最受欢迎的编程语言：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；<br/>2. 支持消息路由：RabbitMQ 可以通过不同的交换器支持不同种类的消息路由；<br/>3. 消息时序：通过延时队列，可以指定消息的延时时间，过期时间TTL等；<br/>4. 支持容错处理：通过交付重试和死信交换器（DLX）来处理消息处理故障；<br/>5. 提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker；<br/>6. 社区活跃度高。<br/></td><td>1.高吞吐：借鉴 Kafka 的设计，单一队列百万消息的堆积能力；<br/>2.高伸缩性：灵活的分布式横向扩展部署架构，整体架构其实和 kafka 很像；<br/>3. 高容错性：通过ACK机制，保证消息一定能正常消费；<br/>4. 持久化、可回溯：消息可以持久化到磁盘中，支持消息回溯；<br/>5. 消息有序：在一个队列中可靠的先进先出（FIFO）和严格的顺序传递；<br/>6. 支持发布&#x2F;订阅和点对点消息模型，支持拉、推两种消息模式；<br/>7. 提供 docker 镜像用于隔离测试和云集群部署，提供配置、指标和监控等功能丰富的 Dashboard。<br/></td></tr><tr><td>缺点</td><td>1. 单机如果超过64个队列或者分区,Load会发生明显飙高的现象,队列越多,load越高,发送消息相应时间变长<br />2. 不支持消息路由，不支持延时发送，不支持消息重试<br />3. 社区更新较慢</td><td align="left">1. Erlang开发，不利于做二次开发和维护<br />2. RabbitMQ吞吐量会低一些<br />3. 不支持消息有序、持久化不好、不支持消息回溯、伸缩性一般。</td><td>1. 不支持消息路由,目前是主要是Java 和c++(c++不成熟)<br /></td></tr></tbody></table><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://blog.csdn.net/qq_19007169/article/details/124702533">面试官问：消息队列该怎么选择？Kafka、RocketMQ 、RabbitMQ 和 ActiveMQ</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>消息队列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>职场小白如何晋升</title>
    <link href="/2022/05/15/%E8%81%8C%E5%9C%BA%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E6%99%8B%E5%8D%87/"/>
    <url>/2022/05/15/%E8%81%8C%E5%9C%BA%E5%B0%8F%E7%99%BD%E5%A6%82%E4%BD%95%E6%99%8B%E5%8D%87/</url>
    
    <content type="html"><![CDATA[<p>在我看来第一点肯定是能力模型.<br>中级开发的能力模型是</p><figure class="highlight gams"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs gams">【关键词】点：初学者，单模块/单场景<br><br><span class="hljs-comment">*初做者，能做好被安排的一般性工作；</span><br><span class="hljs-comment">*有限的知识和技能，能够做与自己专业相关领域的知识管理；</span><br><span class="hljs-comment">*对职位的标准要求、政策、流程等从业所必需了解的知识处于学习成长阶段，尚需要主管或高级别人员对负责的任务和完成的产出进行清晰的定义和沟通，并随时提供支持以达到要求；</span><br><span class="hljs-comment">*通过配合他人完成较复杂的问题。</span><br></code></pre></td></tr></table></figure><p>然后如果自己想晋升到高级开发, 那么对应的能力模型是</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">【关键词】点：熟练手，多模块/多场景<br><br><span class="hljs-comment">*被认为是业务实施的基层主体，能应用专业知识独立解决问题；</span><br><span class="hljs-comment">*具有基础和必要的知识、技能，这种知识与技能集中于本专业的一个领域，并已经在工作中多次得以实践；</span><br><span class="hljs-comment">*能够根据自己的经验来操作或作出相应的决定，或参与解决中等难度问题；遇有较复杂的情形，能够提出问题获得主管或较高级别同事的帮助；</span><br><span class="hljs-comment">*能作为一个有经验且独立的项目成员为项目提供相关信息、问题分析和建议。</span><br></code></pre></td></tr></table></figure><p>之前我有个误区,认为程序员的算法能力需要到达某个水平，其实不然，我们更多的是需要解决问题的能力。</p><p>在和我的直系leader沟通之后，说在他上家公司算法和后端开发是两条不同的晋升路线，对应了2种不同维度的能力模型。所以我个人认为可以在算法能力够用的前提下可以提升自己在常用中间件上的使用和熟悉 来帮助自己更好的去解决不同业务上遇到的问题。</p><ol><li>作为缓存的中间件<ol><li>包括Spring自身的缓存 以及 Caffine</li><li>Redis的掌握</li></ol></li><li>消息队列<ol><li>kafka等</li></ol></li><li>常用的设计模式</li></ol>]]></content>
    
    
    <categories>
      
      <category>职场</category>
      
      <category>晋升</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计原则-单一职责原则</title>
    <link href="/2022/05/14/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/"/>
    <url>/2022/05/14/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>趣学设计模式-工厂模式</title>
    <link href="/2022/05/13/%E8%B6%A3%E5%AD%A6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/05/13/%E8%B6%A3%E5%AD%A6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>先来看一个例子,没有使用工厂模式之前你的代码的样子：</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h26iez4omrj20w90u0q6a.jpg" alt="代码来自Head First P137"></p><p>点评一下：很明显这样写代码非常不好，没有分层，一但要加一个判断则需要新增if else.非常难去维护和更新，并且容易犯错。</p><p>那么如何解决呢？这就是我们今天要讲的工厂模式</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​工厂方法模式是一个 创建型设计模式，在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。</p><h3 id="工厂模式通用类图"><a href="#工厂模式通用类图" class="headerlink" title="工厂模式通用类图"></a>工厂模式通用类图</h3><p>​<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h284d163sxj20ao06k74d.jpg" alt=" 工厂方法模式通用类图"></p><h3 id="工厂方法模式的优点"><a href="#工厂方法模式的优点" class="headerlink" title="工厂方法模式的优点"></a>工厂方法模式的优点</h3><ol><li>良好的封装性,代码结构清晰，我只要一个东西只需要这个产品的<strong>类名</strong>，不用知道创建对象的艰辛过程，降低模块间的耦合。</li><li><strong>拥抱变化</strong>，拓展性非常好，在增加产品类的情况下，只要适当地修改工厂类或者拓展工厂类就行。</li><li><strong>屏蔽产品类</strong>，比如在我们进行数据库开发中从Mysql切换到Oracle只要切换驱动名称即可。</li></ol><h3 id="真实案例"><a href="#真实案例" class="headerlink" title="真实案例"></a>真实案例</h3><div class="code-wrapper"><pre><code class="hljs">#### 简单工厂(实则是一种工厂模式的弱化)</code></pre></div><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h285km8e0cj20gx0ahq3g.jpg" alt="简单工厂模式类图"></p><h4 id="升级为多个工厂类"><a href="#升级为多个工厂类" class="headerlink" title="升级为多个工厂类"></a>升级为多个工厂类</h4><p>所以我们要将 new Pizza的这个方法抽离我们成这个新对象为<strong>工厂</strong>.</p><p>方法</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h280ify8jzj20kp0d8gmd.jpg" alt="image-20220514162731641"></p><ol><li>这样做有什么好处 ？<ol><li>把创建披萨的代码包装成一个类之后，我们只需要改变这个类即可。</li></ol></li><li>如果把工厂定义成一个静态方法和当前使用的有什么差距吗？<ol><li>这样就不能通过继承来改变创建方法的行为。</li></ol></li></ol><p>因此我们可以定义一个 <strong>简单工厂</strong> </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h280pc31m5j20mw0d5759.jpg" alt="image-20220514163409574"></p><p>工厂模式是一个创建型的设计模式</p><p>通常有三个细分的类型：简单工厂、工厂方法 和 抽象工厂。</p><p>其中简单工厂和抽象工厂的原理比较简单，抽象工厂的原理稍微复杂些，并且相对不常用。</p><p>复杂度无法被消除，只能被转移： </p><ul><li>不用工厂模式，if-else 逻辑、创建逻辑和业务代码耦合在一起 </li><li>简单工厂是将不同创建逻辑放到一个工厂类中，if-else 逻辑在这个工厂类中 </li><li>工厂方法是将不同创建逻辑放到不同工厂类中，先用一个工厂类的工厂来来得到某个工厂，再用这个工厂来创建，if-else 逻辑在工厂类的工厂中</li></ul><h3 id="带着问题去学习"><a href="#带着问题去学习" class="headerlink" title="带着问题去学习"></a>带着问题去学习</h3><ol><li>什么时候该用工厂模式？相对于直接 new 来创建对象，用工厂模式来创建究竟有什么好处呢？</li></ol><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p>​首先简单工厂<strong>不是</strong>一个设计模式,</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>工厂方法模式：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>​为创建一组相关或互相依赖的对象提供一个接口，而不需要明确指定具体类</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h285vcho23j20g50aqjrp.jpg" alt="抽象工厂模式的通用类图"></p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一个模式在什么情况下才能够使用，是我包括很多读者都比较困惑的地方。</p><ol><li>Java基础函数库中<ol><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--"><code>java.util.Calendar#getInstance()</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-"><code>java.util.ResourceBundle#getBundle()</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--"><code>java.text.NumberFormat#getInstance()</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-"><code>java.nio.charset.Charset#forName()</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html"><code>java.net.URLStreamHandlerFactory#createURLStreamHandler(String)</code></a> （根据协议返回不同的单例对象）</li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of(E)"><code>java.util.EnumSet#of()</code></a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--"><code>javax.xml.bind.JAXBContext#createMarshaller()</code></a> 及其他类似的方法。</li></ol></li><li>Spring中的应用<ol><li><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2818lkk18j20lb0md0vc.jpg" alt="image-20220514165240270"></li></ol></li><li></li></ol><h3 id="talk-is-cheap-show-me-code"><a href="#talk-is-cheap-show-me-code" class="headerlink" title="talk is cheap, show me code"></a>talk is cheap, show me code</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h281lp0v8dj20j60bfq3l.jpg" alt="image-20220514170515720"></p><p>主函数代码 </p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NvWa</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 声明阴阳八卦炉</span><br>    <span class="hljs-type">AbstractHumanFactory</span> <span class="hljs-variable">YinYangLu</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HumanFactory</span>();<br><br>    <span class="hljs-comment">// 女娲第一次造人，火候不足，缺陷产品</span><br>    System.out.println(<span class="hljs-string">&quot;--造出的第三批人是白色人种--&quot;</span>);<br>    <span class="hljs-type">Human</span> <span class="hljs-variable">whiteHuman</span> <span class="hljs-operator">=</span> YinYangLu.createHuman(WhiteHuman.class);<br>    whiteHuman.getColor();<br>    whiteHuman.talk();<br><br>    <span class="hljs-comment">// 女娲第二次造人，火候过足，又是次品，</span><br>    System.out.println(<span class="hljs-string">&quot;\n--造出的第三批人是黑色人种--&quot;</span>);<br>    <span class="hljs-type">Human</span> <span class="hljs-variable">blackHuman</span> <span class="hljs-operator">=</span> YinYangLu.createHuman(BlackHuman.class);<br>    blackHuman.getColor();<br>    blackHuman.talk();<br><br>    <span class="hljs-comment">// 第三次造人，火候正正好，优品！黄色人种</span><br>    System.out.println(<span class="hljs-string">&quot;\n--造出的第三批人是黄色人种--&quot;</span>);<br>    <span class="hljs-type">Human</span> <span class="hljs-variable">yellowHuman</span> <span class="hljs-operator">=</span> YinYangLu.createHuman(YellowHuman.class);<br>    yellowHuman.getColor();<br>    yellowHuman.talk();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行截图</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sh">--造出的第三批人是白色人种--<br>白色人种的皮肤颜色是白色的!<br>白色人种会说话，一般都是但是单字节。<br><br>--造出的第三批人是黑色人种--<br>黑色人种的皮肤颜色是黑色的!<br>黑人会说话，一般人听不懂。<br><br>--造出的第三批人是黄色人种--<br>黄色人种的皮肤颜色是黄色的!<br>黄色人种会说话，一般说的都是双字节。<br></code></pre></td></tr></table></figure><p>工厂方法模式的模版定义</p><p>​定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p><h3 id="使用推荐"><a href="#使用推荐" class="headerlink" title="使用推荐"></a>使用推荐</h3><ol><li>大部分工厂类都是以“Factory”这个单词结尾的，但也不是必须的，比如 Java 中的 DateFormat、Calender。</li></ol><h3 id="我学习中遇到的问题已经如何解决的"><a href="#我学习中遇到的问题已经如何解决的" class="headerlink" title="我学习中遇到的问题已经如何解决的"></a>我学习中遇到的问题已经如何解决的</h3><ol><li>工厂模式和抽象工厂模式的区别是啥，我们在不同的应用场景中该如何选择呢？</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://time.geekbang.org/column/article/197254">设计模式之美</a></li><li><a href="https://book.douban.com/subject/2243615/">Head First 设计模式中文版</a></li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
      <category>创建型模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于SVN的CICD调研方案</title>
    <link href="/2022/05/12/Jar%E7%83%AD%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/05/12/Jar%E7%83%AD%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="定个小目标"><a href="#定个小目标" class="headerlink" title="定个小目标"></a>定个小目标</h3><p>​ 经过沟通后，第一阶段来说是至少将 dnm 项目的后端(基于Springboot框架) 代码上传到 svn 之后, 能够容器化地去做到热部署。</p><h3 id="CICD工具现状"><a href="#CICD工具现状" class="headerlink" title="CICD工具现状"></a>CICD工具现状</h3><p>​工具的选择：</p><table><thead><tr><th>比较项目</th><th>Jenkins</th><th>Drone</th><th>GitlabCi（不考虑）</th></tr></thead><tbody><tr><td>空间容量清理问题</td><td>需要定时清理，否则占空间越来越大</td><td>无残留</td><td></td></tr><tr><td>插件升级</td><td>每次需要在新环境(测试环境上)，升级测试一下，比较繁琐</td><td>插件都是docker容易,一切都是全自动的.</td><td></td></tr><tr><td>生态的构建</td><td><strong>强大</strong>,插件很多</td><td>完全基于容器来实现的 CI&#x2F;CD 工具，构建的过程也完全是在容器中实现的。</td><td></td></tr><tr><td>CSV支持(关键)</td><td>git、svn</td><td>git. <a href="https://github.com/harness/drone/issues/2799">Do drone Support the SVN?</a></td><td>git</td></tr></tbody></table><p>​其中 新锐Drone 以及 老牌的gitlabCI 需要和git搭配,但是 我们 效能平台部 以及整个雷火的游戏都是在svn上的，所以可以告别这俩只有Jenkins。</p><h3 id="方案选定"><a href="#方案选定" class="headerlink" title="方案选定"></a>方案选定</h3><ol><li>Jenkins + Docker 自动化集成环境搭建</li></ol><h3 id="我遇到的问题"><a href="#我遇到的问题" class="headerlink" title="我遇到的问题"></a>我遇到的问题</h3><ol><li><p>缺失 构建一个maven项目 的选项.<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h25ptdixcxj21pa0u0n2b.jpg" alt="image-20220512164618895"></p><p>【解决方案 I 】是需要去插件市场下载的 maven integration </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h25puly2mvj22ue0u0444.jpg" alt="image-20220512164730229"></p><p>【解决方案 II】 直接在maven的镜像中打jar包进行代码的编译打包，至于我是怎么做的<strong>后文有介绍</strong>.</p></li><li><p>对于java的项目我该配置哪些流程</p><ol><li><p>流程拆解<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h25meu2vudj21hu0ha76h.jpg" alt="整体流程"></p></li><li><p>pull code选择的是最简单的 poll SCM的形式，会每一分钟去触发一次。</p><ol><li><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2bj4j0byhj21je0u0jum.jpg" alt="image-20220517172814179"></p></li><li><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2bj4mkehrj21zi0le0vm.jpg" alt="image-20220517172820245"></p></li></ol></li><li><p>完整的dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> hub.fuxi.netease.com/qa-web/jenkins-maven:<span class="hljs-number">3.6002</span> AS mvn<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /tmp</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> / /tmp</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> mvn clean package</span><br><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span>-jdk-stretch<br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=mvn /tmp/target/jenkinsImage-0.0.1-SNAPSHOT.jar <span class="hljs-string">&quot;/tmp/jenkinsImage-0.0.1-SNAPSHOT.jar&quot;</span></span><br><span class="hljs-comment"># 启动应用程序</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-server&quot;</span>, <span class="hljs-string">&quot;-Xms2048m&quot;</span>, <span class="hljs-string">&quot;-Xmx4096m&quot;</span>, <span class="hljs-string">&quot;-XX:+UseG1GC&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/tmp/jenkinsImage-0.0.1-SNAPSHOT.jar&quot;</span>, <span class="hljs-string">&quot;--spring.profiles.active=test&quot;</span>]</span><br></code></pre></td></tr></table></figure></li><li><p>命令</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">1</span>. docker buildx build -t hub<span class="hljs-selector-class">.fuxi</span><span class="hljs-selector-class">.netease</span>.com/luojiajun/jenkins-build:<span class="hljs-number">1.1</span> .<br>(含义是: 使用当前目录的 Dockerfile 创建镜像，标签为 hub<span class="hljs-selector-class">.fuxi</span><span class="hljs-selector-class">.netease</span>.com/luojiajun/jenkins-build:<span class="hljs-number">1.1</span>)<br><br><span class="hljs-number">2</span>. docker login hub<span class="hljs-selector-class">.fuxi</span><span class="hljs-selector-class">.netease</span><span class="hljs-selector-class">.com</span><br><span class="hljs-number">3</span>. docker push hub<span class="hljs-selector-class">.fuxi</span><span class="hljs-selector-class">.netease</span>.com/luojiajun/jenkins-build:<span class="hljs-number">1.1</span><br></code></pre></td></tr></table></figure><p>命令详解</p><ol><li><table><thead><tr><th>Command</th><th>–</th></tr></thead><tbody><tr><td>docker buildx build</td><td>构建镜像</td></tr><tr><td><strong>–tag, -t:</strong></td><td>镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</td></tr></tbody></table></li></ol></li></ol></li><li><p>Docker部署后发现<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2705a6d4gj22xq08eq5l.jpg" alt="运行失败"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Failed to execute goal org.springframework.boot:spring-boot-maven-plugin:<span class="hljs-number">2.6</span><span class="hljs-number">.7</span>:repackage (repackage) on project jenkinsImage: Execution repackage of goal org.springframework.boot:spring-boot-maven-plugin:<span class="hljs-number">2.6</span><span class="hljs-number">.7</span>:repackage failed: Unable to find main class -&gt; [Help <span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>查看自己的dockerfile文件,只有短短几行就是做了一个复制到&#x2F;tmp下然后进行mvn clean package.结果说找不到主类.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> hub.fuxi.netease.com/qa-web/jenkins-maven:<span class="hljs-number">3.6</span> AS mvn<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /tmp</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> * /tmp</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> mvn clean package</span><br></code></pre></td></tr></table></figure><p>于是自己到镜像中查看</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2708ex4xkj22hw07e0un.jpg" alt="镜像中目录文件">好家伙发现没有src目录。</p><p>找到了一个<a href="https://github.com/moby/moby/issues/15858">病友</a>, 现象是:  </p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h270tl1b9bj20a40a8jri.jpg" alt="copy前">   <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h270ttuxraj20h207y74e.jpg" alt="copy后"></p><p>最后通过修改dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> hub.fuxi.netease.com/qa-web/jenkins-maven:<span class="hljs-number">3.6</span> AS mvn<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /tmp</span><br><span class="hljs-comment"># 注意这里是 / 不是 * </span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> / /tmp  </span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> mvn clean package</span><br></code></pre></td></tr></table></figure><p>最后完美运行。</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h270oopltej22ls0ban00.jpg" alt="主类问题解决正常打包"></p></li><li><p>当把镜像推送上去之后发现,本地运行发现</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># mac M1 上不能运行,linux正常。</span><br>qemu: uncaught target signal 11 (Segmentation fault) - core dumped<br></code></pre></td></tr></table></figure></li><li><p>举个栗子🌰，Jenkins通常内存占用较大，部署在一台单独的机器上称作A，等它镜像打包部署推送完成后,那么如果通知B上的机器去更新其应用呢？</p><ol><li>可以通过ssh去处理,前提是需要到jenkins的插件管理市场中下载ssh.</li></ol><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2bi6p0nmaj22320ns427.jpg" alt="image-20220517165543290"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 登陆docker</span><br><span class="hljs-built_in">cat</span> /home/luojiajun/docker/fuxiDockerPasswd | sudo docker login -u luojiajun  hub.fuxi.netease.com --password-stdin<br><span class="hljs-comment"># 拉取镜像</span><br>sudo docker pull hub.fuxi.netease.com/luojiajun/jenkins-build:latest<br><span class="hljs-comment"># 运行镜像 需要提前 chmod 777.sh文件  </span><br><span class="hljs-built_in">source</span> /home/luojiajun/docker/jenkinsBuild/jenkinsBuild.sh<br></code></pre></td></tr></table></figure><p>通过执行在某个目录下的sh脚本去完成。这样不管是第一次运行镜像还是后续维护都能正确执行。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># shell 文件</span><br><span class="hljs-keyword">if</span> [ $(sudo docker ps -a|grep jenkins_build |<span class="hljs-built_in">wc</span> -l) != <span class="hljs-string">&quot;0&quot;</span> ]<br><span class="hljs-keyword">then</span><br>    sudo docker stop jenkins_build<br>    sudo docker <span class="hljs-built_in">rm</span> jenkins_build<br><span class="hljs-keyword">fi</span><br>sudo docker run -it -d -p 3426:8080 --name=jenkins_build hub.fuxi.netease.com/luojiajun/jenkins-build:latest<br></code></pre></td></tr></table></figure></li><li><p>mvn 下载依赖速度过慢，导致整个CICD流程因为该关键节点所delay。就连下载最基础的Spring framework依赖都花费了10min!.</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2abo4d3xvj21il0u0n27.jpg" alt="image-20220516162440142"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2abokpqw8j22gl0u0q7s.jpg" alt="image-20220516162508450"></p><p><strong>先看效果</strong></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2bhfiw8k4j22fk0qijwb.jpg" alt="image-20220517162936029"></p><ol><li><p>其实就是把本地已经安装好的依赖放到maven的基础镜像库中如何实现可以看步骤一。</p></li><li><p>步骤拆解</p><ol><li><p>第一步</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> hub.fuxi.netease.com/qa-web/jenkins-maven:<span class="hljs-number">3.6</span> AS mvn<br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> /root/.m2/repository/org</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> / /root/.m2/repository/org</span><br></code></pre></td></tr></table></figure></li><li><p>第二步</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># docker buildx build构建镜像</span><br><span class="hljs-comment"># **--tag, -t:** 镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</span><br>docker buildx build -t hub.fuxi.netease.com/qa-web/jenkins-maven:latest .<br><span class="hljs-comment"># 登陆仓库</span><br>docker login hub.fuxi.netease.com<br><span class="hljs-comment"># push镜像</span><br>docker push hub.fuxi.netease.com/luojiajun/jenkins-build:1.1<br></code></pre></td></tr></table></figure></li></ol></li></ol></li><li><p>如何将  ENTRYPOINT  中的启动参数进行抽离，从而做到Dockerfile一次编写后续可以0维护?</p><ol><li></li></ol></li></ol><h3 id="需要解决的事情-持续更新中-按照优先级排序"><a href="#需要解决的事情-持续更新中-按照优先级排序" class="headerlink" title="需要解决的事情(持续更新中,按照优先级排序)"></a>需要解决的事情(持续更新中,按照优先级排序)</h3><ol><li>发送popo的消息</li><li>打tag对映的tag</li><li>多module的问题是如何处理？</li><li>代码的diff,类似发布系统，两个环境的代码进行比对。</li><li>热部署,在服务升级的时候最好不出现502等问题，用户无感知地去升级</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://blog.csdn.net/chenjie19891104/article/details/42807959">热部署</a></li><li><a href="https://zhuanlan.zhihu.com/p/89312003">手把手带你搭建jenkins</a></li><li><a href="https://kms.netease.com/article/38761">基于轻舟CICD的代码静态扫描流程分享</a></li><li><a href="https://www.infoq.cn/article/432edcqbiu5je_dqj3zx">阿里巴巴如何基于 Kubernetes 实践 CI&#x2F;CD</a></li><li><a href="https://www.i4k.xyz/article/weixin_38087538/109080218">修改docker镜像并重新推送到镜像仓库</a></li><li><a href="https://yeasy.gitbook.io/docker_practice/image/multistage-builds">Dockerfile 多阶段构建</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
      <category>CICD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer49丑数</title>
    <link href="/2022/05/12/%E5%89%91%E6%8C%87Offer49%E4%B8%91%E6%95%B0/"/>
    <url>/2022/05/12/%E5%89%91%E6%8C%87Offer49%E4%B8%91%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-49-丑数"><a href="#剑指-Offer-49-丑数" class="headerlink" title="剑指 Offer 49. 丑数"></a><a href="https://leetcode.cn/problems/chou-shu-lcof/">剑指 Offer 49. 丑数</a></h4><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/11 9:16 PM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 注意:</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * &lt;p&gt;特殊情况case : 千万不能忘记去重的问题比如 [0, 1, 2, 3, 4, 5, 6, 6, 8, 9, 10]</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nthUglyNumber</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>    dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">factor2</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>, factor3 = <span class="hljs-number">1</span>, factor5 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">dp2</span> <span class="hljs-operator">=</span> dp[factor2] * <span class="hljs-number">2</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">dp3</span> <span class="hljs-operator">=</span> dp[factor3] * <span class="hljs-number">3</span>;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">dp5</span> <span class="hljs-operator">=</span> dp[factor5] * <span class="hljs-number">5</span>;<br>      dp[i] = Math.min(Math.min(dp2, dp3), dp5);<br>      <span class="hljs-comment">/** 注意这里都是if 不是if else 即没如果当前的是6 那么factor2 和factor3 都是会++的。 */</span><br>      <span class="hljs-keyword">if</span> (dp[i] == dp2) &#123;<br>        factor2++;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (dp[i] == dp3) &#123;<br>        factor3++;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (dp[i] == dp5) &#123;<br>        factor5++;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n];<br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(nthUglyNumber(<span class="hljs-number">10</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><p>​等待更新</p><h3 id="源码链接🔗"><a href="#源码链接🔗" class="headerlink" title="源码链接🔗"></a>源码链接🔗</h3><ol><li><a href="https://github1s.com/ZuccRoger/leetcodeJavaMode/blob/master/src/main/java/com/roger/leetcodejava/jianzhi/solution_49/Solution.java">丑数DP</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>作为职场新人如何做好业务?</title>
    <link href="/2022/05/11/%E4%BD%9C%E4%B8%BA%E8%81%8C%E5%9C%BA%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%9A%E5%8A%A1/"/>
    <url>/2022/05/11/%E4%BD%9C%E4%B8%BA%E8%81%8C%E5%9C%BA%E6%96%B0%E4%BA%BA%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%9A%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<p>应该多花时间在对问题分析，结构化分解，最后通过合理的抽象，形成合适的阶段（Phase）和步骤（Step）上</p><p>有过程分解要好于没有分解，过程分解+对象模型要好于仅仅是过程分解</p><p>我发现这种循序渐进的能力下沉策略，应该是一种更符合实际、更敏捷的方法。因为我们承认模型不是一次性设计出来的，而是迭代演化出来的。</p><h3 id="如何做"><a href="#如何做" class="headerlink" title="如何做"></a>如何做</h3><h4 id="代码怎么写？"><a href="#代码怎么写？" class="headerlink" title="代码怎么写？"></a>代码怎么写？</h4><p>需要上下结合 - 自上而下的结构化分解 + 自下而上的面形对象建模 - 螺旋式地构建系统</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h24fnneqk1j21gl0u077f.jpg" alt="image-20220511140915654"></p><h4 id="业务技术怎么做？"><a href="#业务技术怎么做？" class="headerlink" title="业务技术怎么做？"></a>业务技术怎么做？</h4><p>即业务技术到底是在做业务，还是做技术？业务技术的技术性体现在哪里？</p><p>业务所面临的复杂性并不亚于底层技术</p><h3 id="如何评价是不是一个好的程序员"><a href="#如何评价是不是一个好的程序员" class="headerlink" title="如何评价是不是一个好的程序员"></a>如何评价是不是一个好的程序员</h3><p>​因为程序员最重要的事情就是写代码，好的程序员本质上就是好的工程师，写代码整洁而规范（比如你家做装修的做的又干净又好）</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ol><li><a href="https://blog.csdn.net/alisystemsoftware/article/details/109286754">一文教会你如何写复杂业务代码</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>职场</category>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AutowiredVsResource科普篇</title>
    <link href="/2022/05/10/AutowiredVsResource%E7%A7%91%E6%99%AE%E7%AF%87/"/>
    <url>/2022/05/10/AutowiredVsResource%E7%A7%91%E6%99%AE%E7%AF%87/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>趣学设计模式-代理模式</title>
    <link href="/2022/05/10/%E8%B6%A3%E5%AD%A6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/05/10/%E8%B6%A3%E5%AD%A6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给某一个对象提供代理，并且由代理对象控制对原对象的引用，所以其核心类是代理类。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>以下是代理模式的结构图:</p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h245z6x3iij20qy0j6jsh.jpg" alt="image-20220511083422276"></p><h3 id="光说不练假把式"><a href="#光说不练假把式" class="headerlink" title="光说不练假把式"></a>光说不练假把式</h3><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2465u5ms6j210k0i4763.jpg" alt="image-20220511084045384"></p><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h247hnvs8yj20fy11kmzb.jpg" alt="image-20220511092643311"></p><p>我们以书上的给的例子进行code一步一步敲代码</p><p>给出了调用者Client的代码</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Client</span> &#123;<br>  <span class="hljs-meta">@Autowired</span> ProxySearcher proxySearcher;<br><br>  <span class="hljs-meta">@RequestMapping(&quot;/proxyMode/test&quot;)</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxySearcher.doSearch(<span class="hljs-string">&quot;杨过&quot;</span>, <span class="hljs-string">&quot;小龙女&quot;</span>);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个是代理对象的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxySearcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Searcher</span> &#123;<br>  <span class="hljs-comment">// 维持一个对真实主题的引用</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">RealSearcher</span> <span class="hljs-variable">searcher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RealSearcher</span>();<br><br>  <span class="hljs-keyword">private</span> AccessValidator validator;<br><br>  <span class="hljs-keyword">private</span> Logger logger;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doSearch</span><span class="hljs-params">(String userId, String keyword)</span> &#123;<br>    <span class="hljs-comment">// 如果身份验证成功，则执行查询</span><br>    <span class="hljs-keyword">if</span> (validate(userId)) &#123;<br>      <span class="hljs-comment">// 调用真实主题对象的查询方法</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> searcher.doSearch(userId, keyword);<br>      <span class="hljs-comment">// 记录查询日志</span><br>      <span class="hljs-built_in">this</span>.log(userId);<br>      <span class="hljs-comment">// 返回查询结果</span><br>      <span class="hljs-keyword">return</span> result;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 创建访问验证对象并调用其validate（）方法实现身份验证</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validate</span><span class="hljs-params">(String userId)</span> &#123;<br>    validator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AccessValidator</span>();<br>    <span class="hljs-keyword">return</span> validator.validate(userId);<br>  &#125;<br><br>  <span class="hljs-comment">// 创建日志记录对象并调用log（）方法实现日志记录</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(String userId)</span> &#123;<br>    logger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Logger</span>();<br>    logger.log(userId);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后是真实对象的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealSearcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Searcher</span> &#123;<br>  <span class="hljs-comment">// 模拟查询商务信息</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">doSearch</span><span class="hljs-params">(String userId, String keyword)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;用户&quot;</span> + userId + <span class="hljs-string">&quot;使用关键词&quot;</span> + keyword + <span class="hljs-string">&quot;查询商务信息!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;返回具体内容&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">在数据库中验证用户杨过是否是合法用户?<br>杨过登录成功！<br>用户杨过使用关键词小龙女查询商务信息!<br>更新数据库，用户杨过查询次数加<span class="hljs-number">1</span>！<br></code></pre></td></tr></table></figure><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>​等待更新</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><ol><li>jdk的动态代理<ol><li>利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。</li></ol></li><li>cglib的动态代理<ol><li>是利用asm的开源包,对被代理对象类的class文件加载进来，通过修改其字节码生成的子类来处理。</li></ol></li></ol><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ol><li><p>业务系统的非功能性需求开发</p><ol><li><p>监控、统计、限流、事物、幂、日志。</p></li><li><p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h244x3sls5j20ki07qt95.jpg" alt="image-20220511075740524"></p><p>如图中，当你去找代购购买商品的时候，代购作为代理者可以去验证你的身份并且有相应的日志记录。这些是和业务系统的非功能性的需求开发。</p></li></ol></li><li><p>RPC以及缓存中</p></li></ol><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>代理模式可以去掉客户看不到的内容和服务或者增添额外客户需要的服务。</p><h3 id="和装饰模式相比"><a href="#和装饰模式相比" class="headerlink" title="和装饰模式相比"></a>和装饰模式相比</h3><table><thead><tr><th>代理模式</th><th>装饰模式</th></tr></thead><tbody><tr><td>给真实的类增加一些全新的职责,比如权限控制,缓冲处理,智能引用,远程访问这些和原有的职责不属于同一个问题域。</td><td>是通过装饰类为具体的构件类增加一些相关的职责，是对原有的职责的拓展，而且这些职责是属于同一个问题域的。</td></tr></tbody></table><h3 id="源码链接🔗"><a href="#源码链接🔗" class="headerlink" title="源码链接🔗"></a>源码链接🔗</h3><ol><li><a href="https://github1s.com/ZuccRoger/designMode/blob/HEAD/src/main/java/com/roger/designmode/proxyPattern2/Client.java">商务查询代理模式demo</a></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://refactoringguru.cn/design-patterns/proxy">代理模式</a></li><li><a href="https://book.douban.com/subject/20493657/">设计模式的艺术</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer40最小的k个数</title>
    <link href="/2022/05/10/%E5%89%91%E6%8C%87Offer40%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/"/>
    <url>/2022/05/10/%E5%89%91%E6%8C%87Offer40%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="局部快排"><a href="#局部快排" class="headerlink" title="局部快排"></a>局部快排</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/10 7:36 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] ints = &#123;<br>      <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">213</span>, <span class="hljs-number">12</span>, <span class="hljs-number">312</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">456</span>, <span class="hljs-number">6</span>, <span class="hljs-number">45</span>, <span class="hljs-number">87</span>, <span class="hljs-number">76</span>, <span class="hljs-number">867</span>, <span class="hljs-number">867</span>, <span class="hljs-number">8</span>, <span class="hljs-number">768</span>, <span class="hljs-number">76</span>, <span class="hljs-number">867</span>, <span class="hljs-number">8</span><br>    &#125;;<br>    <span class="hljs-type">int</span>[] kthLargest = getLeastNumbers(ints, <span class="hljs-number">2</span>);<br>    System.out.println(kthLargest);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 最后一个参数表示我们要找的是下标为k-1的数</span><br>    quickSearch(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> Arrays.copyOfRange(arr, <span class="hljs-number">0</span>, k);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] quickSearch(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">calculatedIndex</span> <span class="hljs-operator">=</span> getPartition(nums, lo, hi);<br>    <span class="hljs-keyword">if</span> (calculatedIndex == k) &#123;<br>      <span class="hljs-keyword">return</span> Arrays.copyOfRange(nums, <span class="hljs-number">0</span>, k);<br>    &#125;<br>    <span class="hljs-keyword">return</span> calculatedIndex &gt; k<br>        ? quickSearch(nums, lo, calculatedIndex - <span class="hljs-number">1</span>, k)<br>        : quickSearch(nums, calculatedIndex + <span class="hljs-number">1</span>, hi, k);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">splitNumber</span> <span class="hljs-operator">=</span> nums[start];<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &lt;= nums[end]) &#123;<br>        end--;<br>      &#125;<br>      swap(nums, start, end);<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &gt;= nums[start]) &#123;<br>        start++;<br>      &#125;<br>      swap(nums, start, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpVal</span> <span class="hljs-operator">=</span> nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = tmpVal;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="简单的大根堆"><a href="#简单的大根堆" class="headerlink" title="简单的大根堆"></a>简单的大根堆</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.roger.leetcodejava.jianzhi.solution_40.大根堆;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/10 7:54 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123;<br>      <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">213</span>, <span class="hljs-number">12</span>, <span class="hljs-number">312</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">456</span>, <span class="hljs-number">6</span>, <span class="hljs-number">45</span>, <span class="hljs-number">87</span>, <span class="hljs-number">76</span>, <span class="hljs-number">867</span>, <span class="hljs-number">867</span>, <span class="hljs-number">8</span>, <span class="hljs-number">768</span>, <span class="hljs-number">76</span>, <span class="hljs-number">867</span>, <span class="hljs-number">8</span><br>    &#125;;<br>    <span class="hljs-type">int</span>[] leastNumbers = getLeastNumbers(arr, <span class="hljs-number">2</span>);<br>    System.out.println(leastNumbers);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span><br>    Queue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v2 - v1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>      <span class="hljs-keyword">if</span> (pq.size() &lt; k) &#123;<br>        pq.offer(num);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; pq.peek()) &#123;<br>        pq.poll();<br>        pq.offer(num);<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span>[] ints = pq.stream().mapToInt(Integer::intValue).toArray();<br>    <span class="hljs-keyword">return</span> ints;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h3><ol><li><a href="https://github1s.com/ZuccRoger/leetcodeJavaMode/blob/HEAD/src/main/java/com/roger/leetcodejava/jianzhi/solution_40/%E5%A4%A7%E6%A0%B9%E5%A0%86/Solution.java">剑指offer40</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官:谈谈接口和抽象类有什么区别</title>
    <link href="/2022/05/09/%E8%B0%88%E8%B0%88%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/09/%E8%B0%88%E8%B0%88%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="异同比较"><a href="#异同比较" class="headerlink" title="异同比较"></a>异同比较</h3><p>相同 </p><table><thead><tr><th>比较项</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>实例化</td><td>不能被实例化</td><td>不能被实例化</td></tr><tr><td>允许部分函数实现</td><td>可以</td><td>Java8开始支持default method.</td></tr></tbody></table><p>差异</p><table><thead><tr><th>比较项</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>使用的时机和场景</td><td>主要是代码的复用,强调的是<strong>所属关系</strong></td><td>对类的行为的约束,实现了某个接口就有了对应的行为</td></tr><tr><td>成员变量</td><td>默认是default,可以在子类中重新被定义,也可以重新赋值</td><td>成员变量 只能是public static final .</td></tr><tr><td>支持多重继承</td><td>一个类只能继承一个类</td><td>但是可以实现多个接口</td></tr></tbody></table><h3 id="源码链接"><a href="#源码链接" class="headerlink" title="源码链接"></a>源码链接</h3><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>JavaGuide </li><li><a href="https://time.geekbang.org/column/article/8471">第13讲 | 谈谈接口和抽象类有什么区别？</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官:java线程池是如何实现的,定时线程怎么做到的定时运行？</title>
    <link href="/2022/05/09/%E9%9D%A2%E8%AF%95%E5%AE%98-java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84-%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%EF%BC%9F/"/>
    <url>/2022/05/09/%E9%9D%A2%E8%AF%95%E5%AE%98-java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84-%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%80%8E%E4%B9%88%E5%81%9A%E5%88%B0%E7%9A%84%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试官:请介绍一些类加载,双亲委派模型</title>
    <link href="/2022/05/09/%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/05/09/%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B7%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%BA%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><p>类加载的过程分为加载、链接和初始化。</p><h4 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h4><p>Java将字节码从不同的数据源读取到JVM中，并映射为JVM认可的数据结构(Class对象),这里的数据源可以是各种各样形态的，比如jar文件、class文件,甚至是网络数据源，如果输入数据不是ClassFile的结构，则会抛出ClassFormatError.</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>简单来说就是将定义的类信息平滑地转入到JVM的运行过程中.</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>这个是虚拟机安全的保障,JVM需要核验一下字节信息是否符合JVM的规范,否则就会被认定为<strong>VerifyError</strong>，这样就防止了恶意信息危害JVM的运行，验证阶段可能会触发更多的class加载。</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>创建类或者接口中的静态变量，并且初始化静态变量（侧重在内存空间的分配上）</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>会将常量池中的符号引用替换为直接引用</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>真正地去执行类的初始化代码逻辑，包括静态字段的赋值，以及执行类定义中的静态初始化块内的逻辑。</p><h3 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h3><p>就是说类加载器试图加载某个类型的时候，除非父类型找不到相应的类型，否则尽量将这个任务代理给当前加载器的父加载器去做。使用委派模式的目的是为了避免重复加载Java类型。</p><h3 id="类加载机制的3个基本特征"><a href="#类加载机制的3个基本特征" class="headerlink" title="类加载机制的3个基本特征"></a>类加载机制的3个基本特征</h3><ol><li>双亲委派模型</li><li>可见行</li><li>单一性</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://time.geekbang.org/column/article/9946">请介绍类加载过程，什么是双亲委派模型？</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指OfferII076数组中的第k大的数字</title>
    <link href="/2022/05/09/%E5%89%91%E6%8C%87OfferII076%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2022/05/09/%E5%89%91%E6%8C%87OfferII076%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E5%A4%A7%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h5 id="全量快排"><a href="#全量快排" class="headerlink" title="全量快排"></a>全量快排</h5><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/9 7:37 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;运行结果</span><br><span class="hljs-comment"> *     &lt;p&gt;执行用时： 31 ms , 在所有 Java 提交中击败了 8.13% 的用户</span><br><span class="hljs-comment"> *     &lt;p&gt;内存消耗： 41.6 MB , 在所有 Java 提交中击败了 32.63% 的用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">kthLargest</span> <span class="hljs-operator">=</span> findKthLargest(ints, <span class="hljs-number">2</span>);<br>    System.out.println(kthLargest);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums[k - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> getPartition(nums, start, end);<br>      quickSort(nums, partition + <span class="hljs-number">1</span>, end);<br>      quickSort(nums, start, partition - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">splitNumber</span> <span class="hljs-operator">=</span> nums[start];<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &gt;= nums[end]) &#123;<br>        end--;<br>      &#125;<br>      swap(nums, start, end);<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &lt;= nums[start]) &#123;<br>        start++;<br>      &#125;<br>      swap(nums, start, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpVal</span> <span class="hljs-operator">=</span> nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = tmpVal;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="局部快排"><a href="#局部快排" class="headerlink" title="局部快排"></a>局部快排</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs Java"><br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/9 9:21 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">kthLargest</span> <span class="hljs-operator">=</span> findKthLargest(ints, <span class="hljs-number">2</span>);<br>    System.out.println(kthLargest);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最后一个参数表示我们要找的是下标为k-1的数</span><br>    <span class="hljs-type">int</span>[] ints = quickSearch(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> ints[k - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] quickSearch(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> getPartition(nums, lo, hi);<br>    <span class="hljs-keyword">if</span> (j == k) &#123;<br>      <span class="hljs-keyword">return</span> Arrays.copyOf(nums, j + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span><br>    <span class="hljs-keyword">return</span> j &gt; k ? quickSearch(nums, lo, j - <span class="hljs-number">1</span>, k) : quickSearch(nums, j + <span class="hljs-number">1</span>, hi, k);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">splitNumber</span> <span class="hljs-operator">=</span> nums[start];<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &gt;= nums[end]) &#123;<br>        end--;<br>      &#125;<br>      swap(nums, start, end);<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &lt;= nums[start]) &#123;<br>        start++;<br>      &#125;<br>      swap(nums, start, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpVal</span> <span class="hljs-operator">=</span> nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = tmpVal;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法总结</title>
    <link href="/2022/05/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <url>/2022/05/09/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>java中提供的Arrays.sort方法对于基础类型的排序的底层实现就是采用的快速排序方法.</p> <figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/9 7:48 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> array[] = &#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>, <span class="hljs-number">14</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>&#125;;<br>    System.out.println(<span class="hljs-string">&quot;排序前序列为：&quot;</span>);<br>    printArray(array);<br>    quickSort(array, <span class="hljs-number">0</span>, array.length - <span class="hljs-number">1</span>);<br>    System.out.println(<span class="hljs-string">&quot;排序后序列为：&quot;</span>);<br>    printArray(array);<br>  &#125;<br><br>  <span class="hljs-comment">// 快速排序算法</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> partition(array, start, end);<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 注意： 这要+1 和 -1</span><br><span class="hljs-comment">       *</span><br><span class="hljs-comment">       * &lt;p&gt;因为我们的初始化splitNumber 的值是 array[start] 所以这个start特别关键.</span><br><span class="hljs-comment">       *</span><br><span class="hljs-comment">       * &lt;p&gt;如果我们每次start一样的话，就无法就行 区分 左右。 对 partition;</span><br><span class="hljs-comment">       */</span><br>      quickSort(array, partition + <span class="hljs-number">1</span>, end);<br>      quickSort(array, start, partition - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/** 分区操作 */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">splitNumber</span> <span class="hljs-operator">=</span> array[start];<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>      <span class="hljs-comment">/** 注意这里是&lt;= 否则会造成死循环 */</span><br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &lt;= array[end]) &#123;<br>        end--;<br>      &#125;<br>      swap(array, start, end);<br>      <span class="hljs-comment">/** 注意这里是&gt;= */</span><br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &gt;= array[start]) &#123;<br>        start++;<br>      &#125;<br>      swap(array, start, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>  &#125;<br><br>  <span class="hljs-comment">// 交换序列中元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span> array[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> array[i];<br>    array[i] = array[j];<br>    array[j] = temp;<br>  &#125;<br><br>  <span class="hljs-comment">// 打印序列中元素</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printArray</span><span class="hljs-params">(<span class="hljs-type">int</span> array[])</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> array.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>      <span class="hljs-keyword">if</span> (i != length - <span class="hljs-number">1</span>) &#123;<br>        System.out.print(array[i] + <span class="hljs-string">&quot; &quot;</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(array[i]);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>topK</title>
    <link href="/2022/05/08/topK/"/>
    <url>/2022/05/08/topK/</url>
    
    <content type="html"><![CDATA[<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路:"></a>解题思路:</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><h5 id="全量排序"><a href="#全量排序" class="headerlink" title="全量排序"></a>全量排序</h5><p>但是结果发现效率不高</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/9 7:37 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;运行结果</span><br><span class="hljs-comment"> *     &lt;p&gt;执行用时： 31 ms , 在所有 Java 提交中击败了 8.13% 的用户</span><br><span class="hljs-comment"> *     &lt;p&gt;内存消耗： 41.6 MB , 在所有 Java 提交中击败了 32.63% 的用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] ints = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">kthLargest</span> <span class="hljs-operator">=</span> findKthLargest(ints, <span class="hljs-number">2</span>);<br>    System.out.println(kthLargest);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">findKthLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    quickSort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> nums[k - <span class="hljs-number">1</span>];<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start &lt; end) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">partition</span> <span class="hljs-operator">=</span> getPartition(nums, start, end);<br>      quickSort(nums, partition + <span class="hljs-number">1</span>, end);<br>      quickSort(nums, start, partition - <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPartition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">splitNumber</span> <span class="hljs-operator">=</span> nums[start];<br>    <span class="hljs-keyword">while</span> (start &lt; end) &#123;<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &gt;= nums[end]) &#123;<br>        end--;<br>      &#125;<br>      swap(nums, start, end);<br>      <span class="hljs-keyword">while</span> (start &lt; end &amp;&amp; splitNumber &lt;= nums[start]) &#123;<br>        start++;<br>      &#125;<br>      swap(nums, start, end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> start;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">tmpVal</span> <span class="hljs-operator">=</span> nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = tmpVal;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>注意</strong>找前 K 大&#x2F;前 K 小问题不需要对整个数组进行 O(NlogN)<em>O</em>(<em>N<strong>l</strong>o<strong>g</strong>N</em>) 的排序！</p><h5 id="局部快排"><a href="#局部快排" class="headerlink" title="局部快排"></a>局部快排</h5><p>思想：快排的每一次partition返回的是一个下标，这个下标左边所有的元素小于下标元素，右边的大于下标元素，因此我们只需要在递归时找到下标为k的就能直接返回了，如果下标大于k，那么递归左边，如果下标小于k，那么递归右边； 最坏时间复杂度是O(N²)，平均时间复杂度是O(N)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-comment">// 最后一个参数表示我们要找的是下标为k-1的数</span><br>        <span class="hljs-keyword">return</span> quickSearch(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] quickSearch(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi, <span class="hljs-type">int</span> k) &#123;<br>        <span class="hljs-comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> partition(nums, lo, hi);<br>        <span class="hljs-keyword">if</span> (j == k) &#123;<br>            <span class="hljs-keyword">return</span> Arrays.copyOf(nums, j + <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span><br>        <span class="hljs-keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="hljs-number">1</span>, k): quickSearch(nums, j + <span class="hljs-number">1</span>, hi, k);<br>    &#125;<br><br>    <span class="hljs-comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> nums[lo];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> lo, j = hi + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);<br>            <span class="hljs-keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);<br>            <span class="hljs-keyword">if</span> (i &gt;= j) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> nums[j];<br>            nums[j] = nums[i];<br>            nums[i] = t;<br>        &#125;<br>        nums[lo] = nums[j];<br>        nums[j] = v;<br>        <span class="hljs-keyword">return</span> j;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/#%E4%BA%8C%E3%80%81%E5%A4%A7%E6%A0%B9%E5%A0%86%E5%89%8D-k-%E5%B0%8F-/-%E5%B0%8F%E6%A0%B9%E5%A0%86%EF%BC%88%E5%89%8D-k-%E5%A4%A7,java%E4%B8%AD%E6%9C%89%E7%8E%B0%E6%88%90%E7%9A%84-priorityqueue%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%B5%B7%E6%9D%A5%E6%9C%80%E7%AE%80%E5%8D%95%EF%BC%9A">大根堆(前 K 小) &#x2F; 小根堆（前 K 大),Java中有现成的 PriorityQueue，实现起来最简单：</a></p><p>前置知识铺垫：</p><p>PriorityQueue<code>和</code>Queue<code>的区别在于，它的出队顺序与元素的优先级有关，对</code>PriorityQueue<code>调用</code>remove()<code>或</code>poll()&#96;方法，返回的总是优先级最高的元素。</p><p>这个代码可以说是巨简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span>[] arr = &#123;<br>      <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">213</span>, <span class="hljs-number">12</span>, <span class="hljs-number">312</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">456</span>, <span class="hljs-number">6</span>, <span class="hljs-number">45</span>, <span class="hljs-number">87</span>, <span class="hljs-number">76</span>, <span class="hljs-number">867</span>, <span class="hljs-number">867</span>, <span class="hljs-number">8</span>, <span class="hljs-number">768</span>, <span class="hljs-number">76</span>, <span class="hljs-number">867</span>, <span class="hljs-number">8</span><br>    &#125;;<br>    <span class="hljs-type">int</span>[] leastNumbers = getLeastNumbers(arr, <span class="hljs-number">2</span>);<br>    System.out.println(leastNumbers);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] getLeastNumbers(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> k) &#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span> || arr.length == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">// 默认是小根堆，实现大根堆需要重写一下比较器。</span><br>    Queue&lt;Integer&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;((v1, v2) -&gt; v2 - v1);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>      <span class="hljs-keyword">if</span> (pq.size() &lt; k) &#123;<br>        pq.offer(num);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &lt; pq.peek()) &#123;<br>        pq.poll();<br>        pq.offer(num);<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span>[] ints = pq.stream().mapToInt(Integer::intValue).toArray();<br>    <span class="hljs-keyword">return</span> ints;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h4><p> <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou">二叉搜索树也可以 解决 TopK 问题</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">等待补充<br></code></pre></td></tr></table></figure><h4 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h4><p> <a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/#%E5%9B%9B%E3%80%81%E6%95%B0%E6%8D%AE%E8%8C%83%E5%9B%B4%E6%9C%89%E9%99%90%E6%97%B6%E7%9B%B4%E6%8E%A5%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F%E5%B0%B1%E8%A1%8C%E4%BA%86%EF%BC%9A">数据范围有限时直接计数排序就行了</a></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">等待补充<br></code></pre></td></tr></table></figure><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><ol><li><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/solution/3chong-jie-fa-miao-sha-topkkuai-pai-dui-er-cha-sou/">4种解法秒杀TopK（快排&#x2F;堆&#x2F;二叉搜索树&#x2F;计数排序）❤️</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>topk</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer26.树的子结构</title>
    <link href="/2022/05/08/%E5%89%91%E6%8C%87Offer26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
    <url>/2022/05/08/%E5%89%91%E6%8C%87Offer26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-26-树的子结构"><a href="#剑指-Offer-26-树的子结构" class="headerlink" title="剑指 Offer 26. 树的子结构"></a><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/">剑指 Offer 26. 树的子结构</a></h4><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><pre><code class="hljs java">执行用时：<span class="hljs-number">0</span> ms, 在所有 Java 提交中击败了<span class="hljs-number">100.00</span>%的用户<br>内存消耗：<span class="hljs-number">43.9</span> MB, 在所有 Java 提交中击败了<span class="hljs-number">9.74</span>%的用户<br></code></pre></td></tr></table></figure><p>因为使用的是dfs所以整一个内存的开销比较大。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> com.roger.leetcodejava.TreeNode;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/8 10:53 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-comment">/** 约定空树不是任意一个树的子结构 */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSubStructure</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">null</span> || B == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dfs(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);<br>  &#125;<br><br>  <span class="hljs-comment">/** 以下代码太精髓了! */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(TreeNode A, TreeNode B)</span> &#123;<br>    <span class="hljs-keyword">if</span> (B == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (A == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注意！:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;1. 这里是&amp;&amp; 而不是 ||</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;2. 然后是左右子树分别去进行比对。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> A.val == B.val &amp;&amp; dfs(A.left, B.left) &amp;&amp; dfs(A.right, B.right);<br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">3</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeD</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">2</span>);<br>    treeNodeA.left = treeNodeB;<br>    treeNodeA.right = treeNodeC;<br>    treeNodeB.left = treeNodeD;<br>    treeNodeB.right = treeNodeE;<br><br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeF</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">treeNodeG</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeNode</span>(<span class="hljs-number">1</span>);<br>    treeNodeF.left = treeNodeG;<br><br>    System.out.println(isSubStructure(treeNodeA, treeNodeF));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer16.数值的整数次方</title>
    <link href="/2022/05/07/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <url>/2022/05/07/%E5%89%91%E6%8C%87Offer16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="剑指-Offer-16-数值的整数次方"><a href="#剑指-Offer-16-数值的整数次方" class="headerlink" title="剑指 Offer 16. 数值的整数次方"></a><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/">剑指 Offer 16. 数值的整数次方</a></h4><p>解决方案1: 递归法</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.roger.leetcodejava.jianzhi.solution_16.logN的解法;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/7 7:56 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(myPow(<span class="hljs-number">0.44528</span>, <span class="hljs-number">0</span>));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 因为 x^72次 = x^36 * x ^ 36 所以是一个递归的解决方案.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;然后我们通过奇 和 偶 进行递归.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-comment">/** 处理异常case */</span><br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> n;<br>        <span class="hljs-keyword">return</span> N &gt;= <span class="hljs-number">0</span> ? quickMul(x, N) : <span class="hljs-number">1.0</span> / quickMul(x, -N);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">quickMul</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">long</span> N)</span> &#123;<br>        <span class="hljs-keyword">if</span> (N == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> x;<br>        &#125;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> quickMul(x, N / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> ? result * result * x : result * result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>弊端:</p><ol><li>因为使用递归其实是会使用额外的栈空间。</li></ol><p>解决方法二: 迭代法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.roger.leetcodejava.jianzhi.solution_16.迭代;<br><br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/8 9:07 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 实现 类似 Math.pow函数 这个递归搞不明白哭</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> x</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">myPow</span><span class="hljs-params">(<span class="hljs-type">double</span> x, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-comment">/** 异常case判断 */</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">currentMul</span> <span class="hljs-operator">=</span> x;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">/* 个人这地方理解难 */</span> <br>        result *= currentMul;<br>      &#125;<br>      currentMul *= currentMul;<br>      n = n &gt;&gt; <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    System.out.println(myPow(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>个人感觉这个迭代比较难理解。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官:动态代理是基于什么原理</title>
    <link href="/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86/"/>
    <url>/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官:String、StringBuffer、StringBuilder有什么区别</title>
    <link href="/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><table><thead><tr><th>类型</th><th>特点</th><th>使用场景</th></tr></thead><tbody><tr><td>String</td><td>是<strong>Immutable</strong>的,然后它的类名是final修饰的,属性都是final. 然后因为我们经常要去操作比如修改或者增加String的内容所以我们会用到下面介绍的StringBuffer以及StringBuilder.</td><td>1. 常量的声明 <br />2.<strong>少量</strong>字符串的拼接，一定要避免使用+操作去拼接字符串,因为这样会有大量的无用中间对象，耗费空间并且执行效率低下(新建对象、回收对象需要大量的时间)</td></tr><tr><td>StringBuffer</td><td>首先基于Synchronized是<strong>线程安全</strong>的,导致有额外的性能开销所以一般推荐使用StringBuilder.</td><td><strong>多线程环境</strong> ,比如XML的解析、HTTP参数的解析</td></tr><tr><td>StringBuilder</td><td><strong>线程不安全</strong>,但是是首选的.</td><td><strong>单线程环境</strong>,SQL语句的拼接还有JSON的封装</td></tr></tbody></table><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://time.geekbang.org/column/article/7349">String、StringBuffer、StringBuilder有什么区别？</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试官:请说说你理解中java的引用</title>
    <link href="/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B7%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E4%B8%ADjava%E7%9A%84%E5%BC%95%E7%94%A8/"/>
    <url>/2022/05/06/%E9%9D%A2%E8%AF%95%E5%AE%98-%E8%AF%B7%E8%AF%B4%E8%AF%B4%E4%BD%A0%E7%90%86%E8%A7%A3%E4%B8%ADjava%E7%9A%84%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在Java中除了基本的数据类型之外，其他的都是指向各个对象的对象引用; Java中会根据其生命周期的长短，将引用分为4类.</p><h3 id="引用的类型"><a href="#引用的类型" class="headerlink" title="引用的类型"></a>引用的类型</h3><table><thead><tr><th>引用类型</th><th>特点</th><th>应用场景</th></tr></thead><tbody><tr><td>强引用</td><td>我们平时的编码中,比如 Object obj &#x3D; new Object,这个就是显示的强引用，当JVM内存不足的时候如果想进行垃圾回收，宁可抛出OOM也不会对这部分的强引用做垃圾回收.我们可以在将Object obj &#x3D; null来将个obj进行垃圾回收.</td><td></td></tr><tr><td>软引用</td><td>是通过softReference实现的,比强引用的生命周期要短,当我们JVM内存不足的时候会对这个软引用的对象进行垃圾回收,并且可以配合 ReferenceQueue(后文中统一称为queue)联合使用,当我们对queue进行poll的时候如果是null,否则就是引用对象</td><td>可以用于实现内存敏感的缓存.</td></tr><tr><td>弱引用</td><td>是通过weakReference实现的,比软引用的生命周期还要短,当我们JVM进行GC的时候会优先把弱引用的对象来进行GC.这个要可以配合queue进行。</td><td>内存敏感的缓存.</td></tr><tr><td>虚引用(幻想引用)</td><td>是通过PhantomReference类实现的,无法通过虚引用来访问对象的任何属性以及函数,虚引用仅仅是提供了一种保证对象被finalize后,做某些事情的机制,如果一个对象仅仅被虚引用的话,那么它和没有任何被引用一样,在任何时候都有可能被GC,虚引用必须和queue联合使用,当GC准备回收一个对象的时候,如果发现它还有虚引用,就会在回收内存对象之前，把这个虚引用加入到与之关联的引用队列中,程序可以判断queue中是否已经加入了虚引用来,了解对象是否将要被GC如果发现程序可以当在被回收之前进行相应的处理。</br> ReferenceQueue queue &#x3D; new ReferenceQueue (); PhantomReference pr &#x3D; new PhantomReference (object, queue);</td><td>用于追踪gc，可以在程序被GC前通知用户.</td></tr></tbody></table><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://time.geekbang.org/column/article/6970">引用的特点和应用场景</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer66.构建乘积数组</title>
    <link href="/2022/05/06/%E5%89%91%E6%8C%87Offer66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/"/>
    <url>/2022/05/06/%E5%89%91%E6%8C%87Offer66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof/">剑指 Offer 66. 构建乘积数组🔗</a><br>先直接来一个错误解决方法:</p><p>该错误的解决方法的时间复杂度为O(n^2)</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/6 7:37 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] ints = constructArr(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>        System.out.println(ints);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前算法时间复杂度为n^2.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] constructArr(<span class="hljs-type">int</span>[] a) &#123;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[a.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">currentMulti</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; a.length; j++) &#123;<br>                <span class="hljs-keyword">if</span> (j != i) &#123;<br>                    currentMulti *= a[j];<br>                &#125;<br>            &#125;<br>            result[i] = currentMulti;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上正解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/6 7:45 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span>[] ints = constructArr(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;);<br>        System.out.println(ints);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这里采用了2个for循环 时间复杂度只有O(n);空间复杂度只有个常量级别的所以是O(1);</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] constructArr(<span class="hljs-type">int</span>[] a) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">inputLength</span> <span class="hljs-operator">=</span> a.length;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[inputLength];<br>        <span class="hljs-comment">/** 把每个result[i]左边的乘集得到 */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, product = <span class="hljs-number">1</span>; i &lt; inputLength; product *= a[i], i++) &#123;<br>            result[i] = product;<br>        &#125;<br>        <span class="hljs-comment">/** 我的疑问: 为什么上面是=product 下面这里是*=product. */</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> inputLength - <span class="hljs-number">1</span>, product = <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; product *= a[i], i--) &#123;<br>            result[i] *= product;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么你的maven打包老是出现问题</title>
    <link href="/2022/05/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/"/>
    <url>/2022/05/05/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><h4 id="项目层级和IDEA设置介绍"><a href="#项目层级和IDEA设置介绍" class="headerlink" title="项目层级和IDEA设置介绍:"></a>项目层级和IDEA设置介绍:</h4><p>多模块的目录层级为<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.png" alt="多模块的目录层级"><br>可以看到有3个子模块，分别是dnm-business、dnm-ess4j、dnm-web. IDEA中也设置了:</p><p><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/IDEA%E9%80%92%E5%BD%92%E8%AE%BE%E7%BD%AE.png" alt="IDEA的设置"></p><h3 id="我的操作"><a href="#我的操作" class="headerlink" title="我的操作"></a>我的操作</h3><p>点击了下的clean 然后install. 然后dnm-web下的taget文件目录中运行了java -jar后的运行结果如图：<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E8%BF%90%E8%A1%8C%E9%94%99%E8%AF%AF%E6%88%AA%E5%9B%BE.png" alt="运行结果"><br>总而言之不是缺这个就是缺那个.但是打包是正常的.</p><p>有个项目是多module进行打包的,打包后发现不是这里缺一个类，就是那边一个依赖没有打包完全。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>使用了maven Helper这个IDEA的插件,只要简单地进行对于标红的冲突依赖进行exclude即可，最后重新clean-package.<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E6%9C%80%E7%BB%88pom.xml%E6%B2%A1%E6%9C%89%E5%86%B2%E7%AA%81.png" alt="最终的pom.xml依赖树"></li><li>也可以通过 mvn dependency:tree -Dverbose -includes&#x3D;gid:aid看看所依赖的版本和实际用的版本对不对，gid:aid换成这个依赖的ga信息<br>例如:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs Java">➜  target mvn dependency:tree -Dverbose -Dincludes=io.springfox:springfox-boot-starter<br></code></pre></td></tr></table></figure><h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><p><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%90%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%E5%A5%BD%E5%A5%BD%E7%9A%84-maven%E4%B8%80%E6%89%93%E5%8C%85%E5%B0%B1%E4%B8%A2%E5%A4%B1%E7%B1%BB/%E5%AE%8C%E7%BE%8E%E8%BF%90%E8%A1%8C.png" alt="完美运行"></p>]]></content>
    
    
    <categories>
      
      <category>项目实践</category>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer30包含min函数的栈</title>
    <link href="/2022/05/05/%E5%89%91%E6%8C%87Offer30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/"/>
    <url>/2022/05/05/%E5%89%91%E6%8C%87Offer30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>🔗<a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/">剑指 Offer 30. 包含min函数的栈</a></p><p>通过ArrayList来实现</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/5 7:10 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;第一版代码</span><br><span class="hljs-comment"> *     &lt;p&gt;执行结果： 通过 显示详情 添加备注</span><br><span class="hljs-comment"> *     &lt;p&gt;执行用时： 110 ms , 在所有 Java 提交中击败了 5.66% 的用户 内存消耗： 43.3 MB , 在所有 Java 提交中击败了 56.68% 的用户</span><br><span class="hljs-comment"> *     通过测试用例： 19 / 19</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MinStack</span> <span class="hljs-variable">minStack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinStack</span>();<br>        minStack.push(-<span class="hljs-number">2</span>);<br>        minStack.push(<span class="hljs-number">0</span>);<br>        minStack.push(-<span class="hljs-number">3</span>);<br>        System.out.println(minStack.min());<br>        minStack.pop();<br>        System.out.println(minStack.top());<br>        System.out.println(minStack.min());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> ArrayList&lt;Integer&gt; arrayList;<br><br>    <span class="hljs-comment">/** initialize your data structure here. */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>        arrayList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        arrayList.add(x);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        arrayList.remove(arrayList.size() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">integer</span> <span class="hljs-operator">=</span> arrayList.get(arrayList.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> integer.intValue();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">minValue</span> <span class="hljs-operator">=</span> arrayList.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; arrayList.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (minValue &gt; arrayList.get(i)) &#123;<br>                minValue = arrayList.get(i);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> minValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 LinkedList 来实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">package</span> com.roger.leetcodejava.jianzhi.solution_30.byLinkedList;<br><br><span class="hljs-keyword">import</span> java.util.Deque;<br><span class="hljs-keyword">import</span> java.util.LinkedList;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/5 7:28 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;为什么使用Deque 而不是直接使用Stack</span><br><span class="hljs-comment"> *     &lt;p&gt;首先因为class Stack&lt;E&gt; extends Vector&lt;E&gt; 继承自 Vector</span><br><span class="hljs-comment"> *     &lt;p&gt;Stack作为java语言的栈，是被诟病的地方，作为栈数据结构，却继承了vector，对外暴露了get(index)这样的方法，不是一种合理的实现方式，所以后来java开发提倡使用ArrayDeque</span><br><span class="hljs-comment"> *     &lt;p&gt;另外题目中有要求说调用 min、push 及 pop 的时间复杂度都是O(1) 所以有一个minStack 存放最小值</span><br><span class="hljs-comment"> *     &lt;p&gt;执行用时： 13 ms , 在所有 Java 提交中击败了 63.74% 的用户 内存消耗： 43.5 MB , 在所有 Java 提交中击败了 34.30% 的用户</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>  <span class="hljs-comment">/** initialize your data structure here. */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">MinStack</span> <span class="hljs-variable">minStack</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinStack</span>();<br>    minStack.push(-<span class="hljs-number">2</span>);<br>    minStack.push(<span class="hljs-number">0</span>);<br>    minStack.push(-<span class="hljs-number">3</span>);<br>    System.out.println(minStack.min());<br>    minStack.pop();<br>    System.out.println(minStack.top());<br>    System.out.println(minStack.min());<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; xStack;<br><br>  <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; minStack;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MinStack</span><span class="hljs-params">()</span> &#123;<br>    xStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    minStack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    minStack.push(Integer.MAX_VALUE);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 这里 Math.min(x,minStack.peek()) 是非常巧妙的 因为如果xStack pop的话 minStack也会同步pop</span><br><span class="hljs-comment">     * 并且保证了minStack的第一个元素是最小的.</span><br><span class="hljs-comment">     */</span><br>    xStack.push(x);<br>    minStack.push(Math.min(x, minStack.peek()));<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>    xStack.pop();<br>    minStack.pop();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> xStack.peek();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> minStack.peek();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer33二叉搜索树的后序遍历序列</title>
    <link href="/2022/05/04/%E5%89%91%E6%8C%87Offer33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/"/>
    <url>/2022/05/04/%E5%89%91%E6%8C%87Offer33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/5/4 9:46 AM</span><br><span class="hljs-comment"> *     &lt;p&gt;解题思路: 概念介绍: 二叉搜索树: 左子树上的节点的值 小于 根,右子树上的节点的值 大于 根。 如何判断是否跳出递归? left&gt;right? left right end</span><br><span class="hljs-comment"> *     左子树 右子树 根</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-meta">@Test</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> verifyPostorder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;);<br>    System.out.println(b);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verifyPostorder</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postorder)</span> &#123;<br>    <span class="hljs-keyword">return</span> mainCore(postorder, <span class="hljs-number">0</span>, postorder.length - <span class="hljs-number">1</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">mainCore</span><span class="hljs-params">(<span class="hljs-type">int</span>[] postOrder, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> &#123;<br>    <span class="hljs-comment">/** 跳出递归的条件 */</span><br>    <span class="hljs-keyword">if</span> (start &gt; end) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> start;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> postOrder[end];<br>    <span class="hljs-comment">// 找到第一个右子树的节点</span><br>    <span class="hljs-keyword">for</span> (; count &lt; postOrder.length; count++) &#123;<br>      <span class="hljs-keyword">if</span> (postOrder[count] &gt;= head) &#123;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> count; i &lt; end; i++) &#123;<br>      <span class="hljs-keyword">if</span> (postOrder[i] &lt;= head) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">/** mark! 这里的end需要-1 */</span><br>    <span class="hljs-keyword">return</span> mainCore(postOrder, start, count - <span class="hljs-number">1</span>) &amp;&amp; mainCore(postOrder, count, end - <span class="hljs-number">1</span>);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>请写出一个死锁的demo</title>
    <link href="/2022/05/04/%E8%AF%B7%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84demo/"/>
    <url>/2022/05/04/%E8%AF%B7%E5%86%99%E5%87%BA%E4%B8%80%E4%B8%AA%E6%AD%BB%E9%94%81%E7%9A%84demo/</url>
    
    <content type="html"><![CDATA[<h3 id="先写一个通过Synchronized造成死锁的demo"><a href="#先写一个通过Synchronized造成死锁的demo" class="headerlink" title="先写一个通过Synchronized造成死锁的demo."></a>先写一个通过Synchronized造成死锁的demo.</h3><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTest</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">SynchronizedTest</span> <span class="hljs-variable">synchronizedTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTest</span>();<br>    synchronizedTest.test();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (numA) &#123;<br>                  System.out.println(<span class="hljs-string">&quot;AAA&quot;</span>);<br>                  <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">3</span> * <span class="hljs-number">1000</span>);<br>                  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                  &#125;<br>                  <span class="hljs-keyword">synchronized</span> (numB) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;CCC&quot;</span>);<br>                  &#125;<br>                &#125;<br>              &#125;<br>            &#125;,<br>            <span class="hljs-string">&quot;A&quot;</span>);<br>    a.start();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>              <span class="hljs-meta">@Override</span><br>              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (numB) &#123;<br>                  System.out.println(<span class="hljs-string">&quot;BBB&quot;</span>);<br>                  <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">3</span> * <span class="hljs-number">1000</span>);<br>                  &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                  &#125;<br>                  <span class="hljs-keyword">synchronized</span> (numA) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;DDD&quot;</span>);<br>                  &#125;<br>                &#125;<br>              &#125;<br>            &#125;,<br>            <span class="hljs-string">&quot;B&quot;</span>);<br>    b.start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="那么如何感知是否死锁了呢？"><a href="#那么如何感知是否死锁了呢？" class="headerlink" title="那么如何感知是否死锁了呢？"></a>那么如何感知是否死锁了呢？</h3><ol><li>可以通过dump线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">➜  ~ jps<br><span class="hljs-number">16342</span> Jps<br><span class="hljs-number">2281</span><br><span class="hljs-number">16169</span> Launcher<br><span class="hljs-number">16170</span> SynchronizedTest<br></code></pre></td></tr></table></figure><p>然后通过jstack发现了以下内容:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java">Found one Java-level deadlock:<br>=============================<br><span class="hljs-string">&quot;B&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000013a80b620</span> (object <span class="hljs-number">0x000000076ab33a68</span>, a java.lang.Integer),<br>  which is held by <span class="hljs-string">&quot;A&quot;</span><br><span class="hljs-string">&quot;A&quot;</span>:<br>  waiting to lock monitor <span class="hljs-number">0x000000013a80deb0</span> (object <span class="hljs-number">0x000000076ab33a78</span>, a java.lang.Integer),<br>  which is held by <span class="hljs-string">&quot;B&quot;</span><br><br>Java stack information <span class="hljs-keyword">for</span> the threads listed above:<br>===================================================<br><span class="hljs-string">&quot;B&quot;</span>:<br>at roger.com.javafundament.deadLock.SynchronizedTest$<span class="hljs-number">2.</span>run(SynchronizedTest.java:<span class="hljs-number">52</span>)<br>- waiting to lock &lt;<span class="hljs-number">0x000000076ab33a68</span>&gt; (a java.lang.Integer)<br>- locked &lt;<span class="hljs-number">0x000000076ab33a78</span>&gt; (a java.lang.Integer)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><span class="hljs-string">&quot;A&quot;</span>:<br>at roger.com.javafundament.deadLock.SynchronizedTest$<span class="hljs-number">1.</span>run(SynchronizedTest.java:<span class="hljs-number">31</span>)<br>- waiting to lock &lt;<span class="hljs-number">0x000000076ab33a78</span>&gt; (a java.lang.Integer)<br>- locked &lt;<span class="hljs-number">0x000000076ab33a68</span>&gt; (a java.lang.Integer)<br>at java.lang.Thread.run(Thread.java:<span class="hljs-number">748</span>)<br><br>Found <span class="hljs-number">1</span> deadlock.<br></code></pre></td></tr></table></figure><h3 id="避免死锁的几个常见方法"><a href="#避免死锁的几个常见方法" class="headerlink" title="避免死锁的几个常见方法"></a>避免死锁的几个常见方法</h3><p>1避免同一个线程或者多个锁.</p><ol start="2"><li>避免在一个线程在锁内占用多个资源,尽量保证每个锁只占用一个资源.</li><li>尝试使用定时锁,使用lock.tryLock(timeout)来替代内部锁的机制.</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedTryLockTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">SynchronizedTryLockTest</span> <span class="hljs-variable">synchronizedTest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronizedTryLockTest</span>();<br>        synchronizedTest.test();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lockA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lockB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">if</span> (lockA.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>                                System.out.println(<span class="hljs-string">&quot;AAA&quot;</span>);<br>                                <span class="hljs-keyword">if</span> (lockB.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>                                    System.out.println(<span class="hljs-string">&quot;BBB&quot;</span>);<br>                                &#125;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;)<br>                .start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">if</span> (lockA.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>                                System.out.println(<span class="hljs-string">&quot;CCC&quot;</span>);<br>                                <span class="hljs-keyword">if</span> (lockB.tryLock(<span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>                                    System.out.println(<span class="hljs-string">&quot;DDD&quot;</span>);<br>                                &#125;<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            e.printStackTrace();<br>                        &#125;<br>                    &#125;<br>                &#125;)<br>                .start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="4"><li>对于数据库锁,加锁和解锁必须在同一个数据库连接里面,否则会出现解锁失效的情况.</li></ol><h3 id="github-源码链接🔗"><a href="#github-源码链接🔗" class="headerlink" title="github 源码链接🔗"></a>github 源码链接🔗</h3><ol><li><a href="https://github.com/ZuccRoger/JavaFundament/blob/master/src/main/java/roger/com/javafundament/deadLock/SynchronizedTest.java">SynchronizedTest</a></li><li><a href="https://github.com/ZuccRoger/JavaFundament/blob/master/src/main/java/roger/com/javafundament/deadLock/SynchronizedTryLockTest.java">SynchronizedTryLockTest</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer32.3从上到下打印二叉树</title>
    <link href="/2022/05/04/%E5%89%91%E6%8C%87Offer32-3%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/04/%E5%89%91%E6%8C%87Offer32-3%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">题目链接</a></p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    ArrayList&lt;List&lt;Integer&gt;&gt; resultList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-comment">/** 空树 */</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> resultList;<br>    &#125;<br>    LinkedList&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>      ArrayList&lt;Integer&gt; layerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-comment">/** 个人认为这个分层是比较难的。不知道如何处理 */</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>      <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">firstNode</span> <span class="hljs-operator">=</span> queue.poll();<br>        layerList.add(firstNode.val);<br>        <span class="hljs-keyword">if</span> (firstNode.left != <span class="hljs-literal">null</span>) &#123;<br>          queue.add(firstNode.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (firstNode.right != <span class="hljs-literal">null</span>) &#123;<br>          queue.add(firstNode.right);<br>        &#125;<br>        size--;<br>      &#125;<br>      resultList.add(layerList);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; resultList.size(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>        Collections.reverse(resultList.get(i));<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> resultList;<br>  &#125;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer32.2从上到下打印二叉树</title>
    <link href="/2022/05/03/%E5%89%91%E6%8C%87Offer32-2%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/03/%E5%89%91%E6%8C%87Offer32-2%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for a binary tree node.</span><br><span class="hljs-comment"> * public class TreeNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     TreeNode left;</span><br><span class="hljs-comment"> *     TreeNode right;</span><br><span class="hljs-comment"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.add(root);<br>    List&lt;List&lt;Integer&gt;&gt; lists = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>      ArrayList&lt;Integer&gt; itemList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>      <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> queue.size();<br>      <span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">tmpNode</span> <span class="hljs-operator">=</span> queue.remove();<br>        itemList.add(tmpNode.val);<br>        <span class="hljs-keyword">if</span> (tmpNode.left != <span class="hljs-literal">null</span>) &#123;<br>          queue.add(tmpNode.left);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (tmpNode.right != <span class="hljs-literal">null</span>) &#123;<br>          queue.add(tmpNode.right);<br>        &#125;<br>        len--;<br>      &#125;<br>      lists.add(itemList);<br>    &#125;<br>    <span class="hljs-keyword">return</span> lists;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer32.1从上到下打印二叉树</title>
    <link href="/2022/05/02/%E5%89%91%E6%8C%87Offer32-1%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2022/05/02/%E5%89%91%E6%8C%87Offer32-1%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>题目: <a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">剑指Offer32.1从上到下打印二叉树</a><br>代码块为:</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] levelOrder(TreeNode root) &#123;<br>    <span class="hljs-comment">/** 防止异常case */</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-comment">/** bfs 需要一个额外变量 去存储元素 */</span><br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    queue.add(root);<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>      <span class="hljs-comment">/** 记得这里需要用remove 而不是poll 因为 poll 会返回null 但是remove不会 */</span><br>      root = queue.remove();<br>      list.add(root.val);<br>      <span class="hljs-keyword">if</span> (root.left != <span class="hljs-literal">null</span>) &#123;<br>        queue.add(root.left);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (root.right != <span class="hljs-literal">null</span>) &#123;<br>        queue.add(root.right);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">/** 这里的list 转 int[]数组非常巧妙 */</span><br>    <span class="hljs-keyword">return</span> list.stream().mapToInt(Integer::intValue).toArray();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>剑指Offer13机器人的运动范围</title>
    <link href="/2022/05/02/%E5%89%91%E6%8C%87Offer13%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
    <url>/2022/05/02/%E5%89%91%E6%8C%87Offer13%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>剪绳子(I)</title>
    <link href="/2022/05/02/%E5%89%AA%E7%BB%B3%E5%AD%90/"/>
    <url>/2022/05/02/%E5%89%AA%E7%BB%B3%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<p>题目: <a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof/">剑指 Offer 14- I. 剪绳子</a><br>代码块为:</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/** 处理特殊case */</span><br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">/** 开启dp mode */</span><br><span class="hljs-type">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n + <span class="hljs-number">1</span>];<br>dp[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>dp[<span class="hljs-number">2</span>] = <span class="hljs-number">2</span>;<br>dp[<span class="hljs-number">3</span>] = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>; i &lt;= n; i++) &#123;<br>  <span class="hljs-comment">/** 此处要保证j从下标1开始到 i/2 因为是对称性的 比如 1+3 和 2+2 最后3+1其实 j的范围是 i/2 即可 */</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= (i / <span class="hljs-number">2</span>); j++) &#123;<br>    <span class="hljs-comment">/** 此处要保证 j 以及 i-j是俩下标。 */</span><br>    dp[i] = Math.max(dp[i], dp[j] * dp[i - j]);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> dp[n];<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>剑指Offer</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何注册一个bean</title>
    <link href="/2022/05/01/%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AAbean/"/>
    <url>/2022/05/01/%E5%A6%82%E4%BD%95%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AAbean/</url>
    
    <content type="html"><![CDATA[<p>通过BeanDefinition以及外部的单体对象来注册</p><p>三个方向</p><ol><li>注解<ul><li>@Bean</li><li>@Component</li><li>@Import</li><li></li></ul></li><li>API</li><li></li></ol>]]></content>
    
    
    <categories>
      
      <category>我是面试官系列</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webClient扫盲</title>
    <link href="/2022/05/01/webClient/"/>
    <url>/2022/05/01/webClient/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在spring5之前我们知道有http client 以及 web client两种,毫无意外都是同步执行的,然而webclient是异步回调的.</p><h4 id="发送请求的种类"><a href="#发送请求的种类" class="headerlink" title="发送请求的种类"></a>发送请求的种类</h4><ol><li>apache httpclient</li><li>webclient</li><li>resttemplate</li></ol><table><thead><tr><th></th><th>apache httpclient</th><th>resttemplate</th><th>webclient</th></tr></thead><tbody><tr><td>代码简洁程度</td><td>低</td><td></td><td></td></tr><tr><td></td><td></td><td></td><td></td></tr></tbody></table><p><img src="https://note.youdao.com/yws/res/9441/WEBRESOURCE1403f079524010b181d7f9527f979a6f" alt="image.png"><br>代码量大</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>1. </p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>非阻塞系统(non-blocking servers)</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li>创建</li></ol><ul><li>WebClient.create()<figure class="highlight livecodeserver"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs livecodeserver">WebClient.<span class="hljs-built_in">create</span>()<br><br>WebClient.<span class="hljs-built_in">create</span>(String baseUrl)<br></code></pre></td></tr></table></figure></li><li>WebClient.builder()<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">uriBuilderFactory:</span> Customized UriBuilderFactory <span class="hljs-keyword">to</span> use <span class="hljs-keyword">as</span> a base URL.<br><br><span class="hljs-symbol">defaultUriVariables:</span> <span class="hljs-keyword">default</span> values <span class="hljs-keyword">to</span> use <span class="hljs-keyword">when</span> expanding URI templates.<br><br><span class="hljs-symbol">defaultHeader:</span> Headers <span class="hljs-keyword">for</span> every request.<br><br><span class="hljs-symbol">defaultCookie:</span> Cookies <span class="hljs-keyword">for</span> every request.<br><br><span class="hljs-symbol">defaultRequest:</span> Consumer <span class="hljs-keyword">to</span> customize every request.<br><br><span class="hljs-symbol">filter:</span> Client filter <span class="hljs-keyword">for</span> every request.<br><br><span class="hljs-symbol">exchangeStrategies:</span> HTTP message reader/writer customizations.<br><br><span class="hljs-symbol">clientConnector:</span> HTTP client library settings.<br></code></pre></td></tr></table></figure></li></ul><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><ul><li><strong>retrieve()</strong> 定义如何去提取响应结果.<br>有三种</li></ul><ol><li>toEntity</li><li>bodyToMono</li><li>bodyToFlux<br>定制错误类型<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Mono&lt;Person&gt; result = client.get<span class="hljs-literal">()</span><br>        .uri(<span class="hljs-string">&quot;/persons/&#123;id&#125;&quot;</span>, id).accept(MediaType.APPLICATION_JSON)<br>        .retrieve<span class="hljs-literal">()</span><br>        .on<span class="hljs-constructor">Status(HttpStatus::<span class="hljs-params">is4xxClientError</span>, <span class="hljs-params">response</span> -&gt; <span class="hljs-operator">...</span>)</span><br>        .on<span class="hljs-constructor">Status(HttpStatus::<span class="hljs-params">is5xxServerError</span>, <span class="hljs-params">response</span> -&gt; <span class="hljs-operator">...</span>)</span><br>        .body<span class="hljs-constructor">ToMono(Person.<span class="hljs-params">class</span>)</span>;<br></code></pre></td></tr></table></figure></li></ol><ul><li>exchange()</li><li></li></ul><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-number">1</span>: 参考资料 https://elim<span class="hljs-number">168</span>.github.io/spring/bean/<span class="hljs-number">31</span>.Spring<span class="hljs-variable">%E4</span><span class="hljs-variable">%B9</span><span class="hljs-variable">%8</span>BWebClient<span class="hljs-variable">%E4</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%8</span>B<span class="hljs-variable">%E7</span><span class="hljs-variable">%BB</span><span class="hljs-variable">%8</span>D.html<br></code></pre></td></tr></table></figure><h4 id="我的疑问"><a href="#我的疑问" class="headerlink" title="我的疑问"></a>我的疑问</h4><ol><li>这个webclient需要配置一个http连接池吗？</li><li>Jetty vs  Netty</li></ol><h4 id="项目中遇到的困难"><a href="#项目中遇到的困难" class="headerlink" title="项目中遇到的困难"></a>项目中遇到的困难</h4><ol><li>302的时候无法捕获到这个cookie</li></ol><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li><a href="https://docs.spring.io/spring-framework/docs/current/reference/html/web-reactive.html#webflux-client">spring.io Web Clinent</a></li><li><a href="https://www.baeldung.com/spring-webclient-resttemplate">link</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AOP常见错误</title>
    <link href="/2022/05/01/AOP%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <url>/2022/05/01/AOP%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>AOP本质上是一个代理模式<br>Spring AOP 的底层是动态代理。而创建代理的方式有两种，JDK 的方式和 CGLIB 的方式。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>详述bean生命周期</title>
    <link href="/2022/05/01/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/05/01/bean%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="抛出问题"><a href="#抛出问题" class="headerlink" title="抛出问题"></a>抛出问题</h3><ol><li></li></ol><p>问题解决：<br>即 Spring 初始化单例类的一般过程，基本都是 getBean()-&gt;doGetBean()-&gt;getSingleton()，如果发现 Bean 不存在，则调用 createBean()-&gt;doCreateBean() 进行实例化。</p><h3 id="class到Bean中间经历了哪些生命周期什么？"><a href="#class到Bean中间经历了哪些生命周期什么？" class="headerlink" title="class到Bean中间经历了哪些生命周期什么？"></a>class到Bean中间经历了哪些生命周期什么？</h3><h3 id=""><a href="#" class="headerlink" title=""></a></h3><p>元信息配置阶段</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>notify&amp;wait实现生产者消费者模型</title>
    <link href="/2022/04/30/notify&amp;wait%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
    <url>/2022/04/30/notify&amp;wait%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>生产者</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Queue;<br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/4/19 8:06 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Producer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Producer.class);<br>  <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> maxSize;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Producer</span><span class="hljs-params">(Queue&lt;Integer&gt; queue, <span class="hljs-type">int</span> maxSize, String threadName)</span> &#123;<br>    <span class="hljs-built_in">super</span>(threadName);<br>    <span class="hljs-built_in">this</span>.queue = queue;<br>    <span class="hljs-built_in">this</span>.maxSize = maxSize;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.run();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">2</span>));<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>      <span class="hljs-comment">/** 在条件判断之前给共享资源加锁 */</span><br>      <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>        <span class="hljs-keyword">while</span> (queue.size() == maxSize) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            logger.info(<span class="hljs-string">&quot;消息队列已满: 生产者线程调用wait方法进入等待状态 ...&quot;</span>);<br>            queue.wait();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">messageId</span> <span class="hljs-operator">=</span> pc++;<br>        logger.info(<span class="hljs-string">&quot;生产消息:&#123;&#125; &quot;</span>, messageId);<br>        queue.add(messageId);<br>        queue.notify();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">import</span> java.util.Queue;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/4/19 8:13 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Consumer.class);<br>  <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Consumer</span><span class="hljs-params">(Queue&lt;Integer&gt; queue, String threadName)</span> &#123;<br>    <span class="hljs-built_in">super</span>(threadName);<br>    <span class="hljs-built_in">this</span>.queue = queue;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">super</span>.run();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">synchronized</span> (queue) &#123;<br>        <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            logger.info(<span class="hljs-string">&quot;消息队列为空: 消费者线程调用wait方法进入等待状态 ...&quot;</span>);<br>            queue.wait();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>          &#125;<br>        &#125;<br>        logger.info(<span class="hljs-string">&quot;消费信息:&#123;&#125;&quot;</span>, queue.remove());<br>        queue.notify();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/4/19 8:46 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Launch</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Producer</span>(queue, maxSize, <span class="hljs-string">&quot;producer-thread&quot;</span>).start();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Consumer</span>(queue, <span class="hljs-string">&quot;consumer-thread&quot;</span>).start();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行截图:<br><img src="http://pfp.ps.netease.com/kmspvt/file/625e4fc4935599814c6250b2Th1x8iSc01?sign=1m7oZcDS-4WGCnZHfhOFX8Lg0lw=&expire=1651311214" alt="image.png"><br>源码自取:<br><a href="https://github.com/ZuccRoger/JavaFundament">https://github.com/ZuccRoger/JavaFundament</a><br>包路径为：<a href="https://github.com/ZuccRoger/JavaFundament/tree/master/src/main/java/roger/com/javafundament/produceAndConsume/notifyAndWait">https://github.com/ZuccRoger/JavaFundament/tree/master/src/main/java/roger/com/javafundament/produceAndConsume/notifyAndWait</a></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring中如何自己去实现一个starter</title>
    <link href="/2022/04/30/spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAstarter/"/>
    <url>/2022/04/30/spring%E4%B8%AD%E5%A6%82%E4%BD%95%E8%87%AA%E5%B7%B1%E5%8E%BB%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAstarter/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是自动装配"><a href="#什么是自动装配" class="headerlink" title="什么是自动装配"></a>什么是自动装配</h3><p>通过注解或者一些简单的配置就能在 Spring Boot 的帮助下实现某块功能。</p><h3 id="spring是如何实现自动装配的？"><a href="#spring是如何实现自动装配的？" class="headerlink" title="spring是如何实现自动装配的？"></a>spring是如何实现自动装配的？</h3><p>springboot的自动配置是基于spring factories机制实现的，这是一种服务发现机制，类似Java SPI。 spring会自动扫描所有jar包类路径下的META-INF&#x2F;spring.factories文件，读取其中的类型并进项实例化。<br>spring.factories文件中的内容实际上就是要导入的接口名和实现类组成的kv对，key为文件中定义的一些标识工厂类，value就是能自动配置的一些工厂实现的类。   在自动装配时，其实就是去加载AutoConfiguration类和实现类，<br>在加载自动配置类的时候，并不是将spring.factories的配置全部加载进来，而是通过@Conditional等注解的判断进行动态加载，只有当容器满足了注解中的条件的时候，才会将类加载到容器中</p><hr><p>偷来的八股文：<br>自动装配依托@Import的强大功能和spring的SPI机制。通过SPI机制发现类，通过@Import将类注册到spring中。@SpringBootApplication这个注解时组合注解里面包含自动扫描注解，里面包含一个EnableAutoConfiguration注解，这个注解作用是去寻找每个jar包里面的META-INF&#x2F;spring.factories文件，之后将文件里面的类全部实例化。<br>每个需要自动装配的模块都需要编写一个AutoConfiguration类，这些AutoConfiguration类的原理大概是通过@Import注解将其属性类Properties全部到注册spring容器中，属性类通过注解@ConfigurationProperties从配置文件里面取到配置值。之后将关键的类注册为bean自动注入属性类进行初始化完成自动装配的功能。</p><h4 id="细分相关知识如下："><a href="#细分相关知识如下：" class="headerlink" title="细分相关知识如下："></a>细分相关知识如下：</h4><p>我们知道</p><figure class="highlight less"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span> = <span class="hljs-variable">@SpringBootConfiguration</span>+<span class="hljs-variable">@EnableAutoConfiguration</span>+<span class="hljs-variable">@ComponentScan</span><br></code></pre></td></tr></table></figure><p>我们要重点关注这个@EnableAutoConfiguration.<br>看到 EnableAutoConfiguration.class 文件有个@Import({AutoConfigurationImportSelector.class})</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><ol><li>第一步会去看这个<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/%E6%A3%80%E6%B5%8B%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D.png" alt="image.png"><br>可以看到默认是spring.boot.enableautoconfiguration的值默认是true。</li><li>得到排除的依赖项<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/%E5%BE%97%E5%88%B0%E6%8E%92%E9%99%A4%E7%9A%84%E4%BE%9D%E8%B5%96%E9%A1%B9.png" alt="image"></li><li>得到配置内容<br><img src="https://eshop-photo1.oss-cn-beijing.aliyuncs.com/blog/%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D/%E5%BE%97%E5%88%B0factories%E4%B8%AD%E7%9A%84bean.png" alt="img"></li></ol><h3 id="如何自己实现一个starter？"><a href="#如何自己实现一个starter？" class="headerlink" title="如何自己实现一个starter？"></a>如何自己实现一个starter？</h3><ol><li>在resources&#x2F;META-INF中新建spring.factories文件<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>com.roger.demospringbootstarter.config.DemoConfig<br></code></pre></td></tr></table></figure></li><li>在这个EnableAutoConfiguration的属性所对应的java文件中写入自己想装配的bean.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 骆佳俊</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2022/4/27 10:21 AM</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoConfig</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(DemoConfig.class);<br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">demoService</span><span class="hljs-params">()</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;我是自动装配进来的&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在外部如何引用？<br>本地打包的时候可以直接点击mvn clean pakcage.然后会在本地的maven仓库中出现该jar文件。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.roger<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>demo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="如何自动配置是否生效"><a href="#如何自动配置是否生效" class="headerlink" title="如何自动配置是否生效"></a>如何自动配置是否生效</h3><p>启动的时候可以增加-Ddebug参数.<br>会有以下4种形式的输出</p><table><thead><tr><th>类型</th><th>意义</th></tr></thead><tbody><tr><td>Positive matches</td><td>@Conditional条件为真，配置类被Spring容器加载</td></tr><tr><td>Negative matches</td><td>@Conditional条件为假，配置类未被Spring容器加载</td></tr><tr><td>Exclusions</td><td>应用端明确排除加载配置</td></tr><tr><td>Unconditional classes</td><td>自动配置类不包含任何类级别的条件，也就是说，类始终会被自动加载。</td></tr></tbody></table><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">Unconditional classes:<br>----------------------<br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.ConfigurationPropertiesAutoConfiguration</span><br><br>    com<span class="hljs-selector-class">.roger</span><span class="hljs-selector-class">.demospringbootstarter</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.DemoConfig</span><br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.LifecycleAutoConfiguration</span><br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.PropertyPlaceholderAutoConfiguration</span><br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.availability</span><span class="hljs-selector-class">.ApplicationAvailabilityAutoConfiguration</span><br><br>    org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.info</span>.ProjectInfoAutoConfiguration<br></code></pre></td></tr></table></figure><p>最终在输出的命令行中我看见了    com.roger.demospringbootstarter.config.DemoConfig 该Bean.</p><h3 id="最后的效果"><a href="#最后的效果" class="headerlink" title="最后的效果"></a>最后的效果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">30</span> <span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">06.150</span>  INFO <span class="hljs-number">56979</span> --- [           main] r.c.j.JavaFundamentApplication           : Starting JavaFundamentApplication using Java <span class="hljs-number">1.8</span><span class="hljs-number">.0_312</span> on YolandadeMacBook-Air.local with PID <span class="hljs-number">56979</span> (/Users/yolanda/code/javaProject/javaFundament/target/classes started by yolanda in /Users/yolanda/code/javaProject/javaFundament)<br><span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">30</span> <span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">06.152</span>  INFO <span class="hljs-number">56979</span> --- [           main] r.c.j.JavaFundamentApplication           : No active profile set, falling back to <span class="hljs-number">1</span> <span class="hljs-keyword">default</span> profile: <span class="hljs-string">&quot;default&quot;</span><br><span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">30</span> <span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">09.567</span>  INFO <span class="hljs-number">56979</span> --- [           main] c.r.d.config.DemoConfig                  : 我是自动装配进来的<br>asdas dlksa dsj kldsja kldsaj klasjdl ksaj<br><span class="hljs-number">2022</span>-<span class="hljs-number">04</span>-<span class="hljs-number">30</span> <span class="hljs-number">10</span>:<span class="hljs-number">57</span>:<span class="hljs-number">09.656</span>  INFO <span class="hljs-number">56979</span> --- [           main] r.c.j.JavaFundamentApplication           : Started JavaFundamentApplication in <span class="hljs-number">3.71</span> seconds (JVM running <span class="hljs-keyword">for</span> <span class="hljs-number">4.835</span>)<br>Disconnected from the target VM, address: <span class="hljs-string">&#x27;127.0.0.1:61225&#x27;</span>, transport: <span class="hljs-string">&#x27;socket&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="源代码自取"><a href="#源代码自取" class="headerlink" title="源代码自取"></a>源代码自取</h3><ol><li><a href="https://github.com/ZuccRoger/AutoConfigaration">https://github.com/ZuccRoger/AutoConfigaration</a></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html">Javaguide</a></li><li><a href="https://time.geekbang.org/course/detail/100023501-87617">极客时间-了解自动装配实现原理</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>原创</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
